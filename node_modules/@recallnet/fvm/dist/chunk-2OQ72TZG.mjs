import {
  __export
} from "./chunk-7P6ASYW6.mjs";

// src/utils/base32.ts
var base32_exports = {};
__export(base32_exports, {
  decode: () => decode,
  encode: () => encode
});
var RFC4648 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var RFC4648_HEX = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
var CROCKFORD = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function encode(data, variant = "RFC4648", options = { padding: false }) {
  options = options || {};
  let alphabet, defaultPadding;
  switch (variant) {
    case "RFC3548":
    case "RFC4648":
      alphabet = RFC4648;
      defaultPadding = true;
      break;
    case "RFC4648-HEX":
      alphabet = RFC4648_HEX;
      defaultPadding = true;
      break;
    case "Crockford":
      alphabet = CROCKFORD;
      defaultPadding = false;
      break;
  }
  if (!alphabet) throw new Error(`Unknown base32 variant: ${variant}`);
  const padding = options.padding !== void 0 ? options.padding : defaultPadding;
  const view = toDataView(data);
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i = 0; i < view.byteLength; i++) {
    value = value << 8 | view.getUint8(i);
    bits += 8;
    while (bits >= 5) {
      output += alphabet[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += alphabet[value << 5 - bits & 31];
  }
  if (padding) {
    while (output.length % 8 !== 0) {
      output += "=";
    }
  }
  return output;
}
function decode(input, variant = "RFC4648") {
  let alphabet;
  switch (variant) {
    case "RFC3548":
    case "RFC4648":
      alphabet = RFC4648;
      input = input.replace(/=+$/, "");
      break;
    case "RFC4648-HEX":
      alphabet = RFC4648_HEX;
      input = input.replace(/=+$/, "");
      break;
    case "Crockford":
      alphabet = CROCKFORD;
      input = input.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1");
      break;
    default:
      throw new Error("Unknown base32 variant: " + variant);
  }
  const length = input.length;
  let bits = 0;
  let value = 0;
  let index = 0;
  const output = new Uint8Array(length * 5 / 8 | 0);
  for (let i = 0; i < length; i++) {
    value = value << 5 | readChar(alphabet, input[i]);
    bits += 5;
    if (bits >= 8) {
      output[index++] = value >>> bits - 8 & 255;
      bits -= 8;
    }
  }
  return output.buffer;
}
function readChar(alphabet, char) {
  const idx = alphabet.indexOf(char);
  if (idx === -1) {
    throw new Error("Invalid character found: " + char);
  }
  return idx;
}
function toDataView(data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray)
    return new DataView(data.buffer, data.byteOffset, data.byteLength);
  if (data instanceof ArrayBuffer) return new DataView(data);
  throw new TypeError(
    "Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray"
  );
}

// src/utils/convert.ts
import { fromString } from "uint8arrays/from-string";
function bigintToUint8Array(value, pad = false) {
  if (value === 0 || value === "0" || value === 0n) return new Uint8Array(0);
  const num = BigInt(value);
  let hex = num.toString(16);
  if (hex.length % 2 === 1) hex = `0${hex}`;
  if (pad) hex = `00${hex}`;
  return fromString(hex, "hex");
}
function toBigInt(value) {
  const Nibbles = "0123456789abcdef";
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        throw new Error(`invalid BigNumberish string: ${e.message}`);
      }
  }
}

// src/utils/leb128/unsigned.ts
var unsigned_exports = {};
__export(unsigned_exports, {
  decode: () => decode2,
  encode: () => encode2,
  read: () => read,
  readBigInt: () => readBigInt,
  write: () => write
});

// src/utils/leb128/common.ts
var Stream = class {
  buffer;
  _bytesRead;
  constructor(buf = Uint8Array.from([])) {
    this.buffer = buf;
    this._bytesRead = 0;
  }
  read(size) {
    const data = this.buffer.slice(0, size);
    this.buffer = this.buffer.slice(size);
    this._bytesRead += size;
    return data;
  }
  write(buf) {
    this.buffer = Uint8Array.from([...this.buffer, ...buf]);
  }
};

// src/utils/leb128/unsigned.ts
function read(stream) {
  return readBigInt(stream).toString();
}
function readBigInt(stream) {
  let num = 0n;
  let shift = 0;
  let byte;
  while (true) {
    byte = stream.read(1)[0];
    num |= BigInt(byte & 127) << BigInt(shift);
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return num;
}
function write(number, stream) {
  let num = BigInt(number);
  while (true) {
    const i = Number(num & 0x7fn);
    num >>= 7n;
    if (num === 0n) {
      stream.write(new Uint8Array([i]));
      break;
    } else {
      stream.write(new Uint8Array([i | 128]));
    }
  }
}
function encode2(num) {
  const stream = new Stream();
  write(num, stream);
  return stream.buffer;
}
function decode2(buffer) {
  const stream = new Stream(buffer);
  return read(stream);
}

// src/utils/leb128/index.ts
var leb128_exports = {};
__export(leb128_exports, {
  signed: () => signed_exports,
  unsigned: () => unsigned_exports
});

// src/utils/leb128/signed.ts
var signed_exports = {};
__export(signed_exports, {
  decode: () => decode3,
  encode: () => encode3,
  read: () => read2,
  readBigInt: () => readBigInt2,
  write: () => write2
});
function read2(stream) {
  return readBigInt2(stream).toString();
}
function readBigInt2(stream) {
  let num = 0n;
  let shift = 0;
  let byte;
  while (true) {
    byte = stream.read(1)[0];
    num |= BigInt(byte & 127) << BigInt(shift);
    shift += 7;
    if ((byte & 128) === 0) {
      break;
    }
  }
  if ((byte & 64) !== 0) {
    num |= ~0n << BigInt(shift);
  }
  return num;
}
function write2(number, stream) {
  let num = BigInt(number);
  let more = true;
  while (more) {
    let byte = Number(num & 0x7fn);
    num >>= 7n;
    const isLastByte = num === 0n && (byte & 64) === 0 || num === -1n && (byte & 64) !== 0;
    if (isLastByte) {
      more = false;
    } else {
      byte |= 128;
    }
    stream.write(new Uint8Array([byte]));
  }
}
function encode3(num) {
  const stream = new Stream();
  write2(num, stream);
  return stream.buffer;
}
function decode3(buffer) {
  const stream = new Stream(buffer);
  return read2(stream);
}

export {
  encode,
  decode,
  base32_exports,
  bigintToUint8Array,
  toBigInt,
  unsigned_exports,
  leb128_exports
};
