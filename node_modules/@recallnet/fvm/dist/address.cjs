"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/address/index.ts
var address_exports = {};
__export(address_exports, {
  Address: () => Address,
  AddressActor: () => AddressActor,
  AddressBls: () => AddressBls,
  AddressDelegated: () => AddressDelegated,
  AddressId: () => AddressId,
  AddressSecp256k1: () => AddressSecp256k1,
  FilEthAddress: () => FilEthAddress
});
module.exports = __toCommonJS(address_exports);
var import_compare2 = require("uint8arrays/compare");
var import_concat = require("uint8arrays/concat");
var import_from_string2 = require("uint8arrays/from-string");
var import_to_string = require("uint8arrays/to-string");

// src/artifacts/address.ts
var ACTOR_ID_ETHEREUM_MASK = 255;
var ACTOR_ID_ETHEREUM_MASK_LEN = 12;
var NetworkPrefix = /* @__PURE__ */ ((NetworkPrefix2) => {
  NetworkPrefix2["Mainnet"] = "f";
  NetworkPrefix2["Testnet"] = "t";
  return NetworkPrefix2;
})(NetworkPrefix || {});
var ETH_ADDRESS_LEN = 20;
var SUB_ADDRESS_MAX_LEN = 54;
var BLS_PAYLOAD_LEN = 48;
var ACTOR_PAYLOAD_LEN = 20;
var SECP256K1_PAYLOAD_LEN = 20;
var ID_PAYLOAD_MAX_NUM = 2n ** 63n - 1n;

// src/utils/address.ts
var import_blakejs = __toESM(require("blakejs"), 1);
var import_compare = require("uint8arrays/compare");
function getChecksum(payload) {
  const blakeCtx = import_blakejs.default.blake2bInit(4);
  import_blakejs.default.blake2bUpdate(blakeCtx, payload);
  return import_blakejs.default.blake2bFinal(blakeCtx);
}
function getLeb128Length(input) {
  let count = 0;
  while (count < input.length) {
    const byte = input[count];
    count++;
    if (byte < 128) break;
  }
  if (count == input.length) return -1;
  return count;
}
var validateNetworkPrefix = (networkPrefix) => Object.values(NetworkPrefix).includes(networkPrefix);
var isMaskedIdEthAddress = (ethAddr) => {
  const idMask = new Uint8Array(ACTOR_ID_ETHEREUM_MASK_LEN);
  idMask[0] = ACTOR_ID_ETHEREUM_MASK;
  return ethAddr.length === ETH_ADDRESS_LEN && (0, import_compare.compare)(idMask, ethAddr.slice(0, ACTOR_ID_ETHEREUM_MASK_LEN)) === 0;
};

// src/utils/base32.ts
var RFC4648 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
var RFC4648_HEX = "0123456789ABCDEFGHIJKLMNOPQRSTUV";
var CROCKFORD = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
function encode(data, variant = "RFC4648", options = { padding: false }) {
  options = options || {};
  let alphabet, defaultPadding;
  switch (variant) {
    case "RFC3548":
    case "RFC4648":
      alphabet = RFC4648;
      defaultPadding = true;
      break;
    case "RFC4648-HEX":
      alphabet = RFC4648_HEX;
      defaultPadding = true;
      break;
    case "Crockford":
      alphabet = CROCKFORD;
      defaultPadding = false;
      break;
  }
  if (!alphabet) throw new Error(`Unknown base32 variant: ${variant}`);
  const padding = options.padding !== void 0 ? options.padding : defaultPadding;
  const view = toDataView(data);
  let bits = 0;
  let value = 0;
  let output = "";
  for (let i = 0; i < view.byteLength; i++) {
    value = value << 8 | view.getUint8(i);
    bits += 8;
    while (bits >= 5) {
      output += alphabet[value >>> bits - 5 & 31];
      bits -= 5;
    }
  }
  if (bits > 0) {
    output += alphabet[value << 5 - bits & 31];
  }
  if (padding) {
    while (output.length % 8 !== 0) {
      output += "=";
    }
  }
  return output;
}
function decode(input, variant = "RFC4648") {
  let alphabet;
  switch (variant) {
    case "RFC3548":
    case "RFC4648":
      alphabet = RFC4648;
      input = input.replace(/=+$/, "");
      break;
    case "RFC4648-HEX":
      alphabet = RFC4648_HEX;
      input = input.replace(/=+$/, "");
      break;
    case "Crockford":
      alphabet = CROCKFORD;
      input = input.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1");
      break;
    default:
      throw new Error("Unknown base32 variant: " + variant);
  }
  const length = input.length;
  let bits = 0;
  let value = 0;
  let index = 0;
  const output = new Uint8Array(length * 5 / 8 | 0);
  for (let i = 0; i < length; i++) {
    value = value << 5 | readChar(alphabet, input[i]);
    bits += 5;
    if (bits >= 8) {
      output[index++] = value >>> bits - 8 & 255;
      bits -= 8;
    }
  }
  return output.buffer;
}
function readChar(alphabet, char) {
  const idx = alphabet.indexOf(char);
  if (idx === -1) {
    throw new Error("Invalid character found: " + char);
  }
  return idx;
}
function toDataView(data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray)
    return new DataView(data.buffer, data.byteOffset, data.byteLength);
  if (data instanceof ArrayBuffer) return new DataView(data);
  throw new TypeError(
    "Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray"
  );
}

// src/utils/convert.ts
var import_from_string = require("uint8arrays/from-string");
function bigintToUint8Array(value, pad = false) {
  if (value === 0 || value === "0" || value === 0n) return new Uint8Array(0);
  const num = BigInt(value);
  let hex = num.toString(16);
  if (hex.length % 2 === 1) hex = `0${hex}`;
  if (pad) hex = `00${hex}`;
  return (0, import_from_string.fromString)(hex, "hex");
}

// src/utils/leb128/common.ts
var Stream = class {
  buffer;
  _bytesRead;
  constructor(buf = Uint8Array.from([])) {
    this.buffer = buf;
    this._bytesRead = 0;
  }
  read(size) {
    const data = this.buffer.slice(0, size);
    this.buffer = this.buffer.slice(size);
    this._bytesRead += size;
    return data;
  }
  write(buf) {
    this.buffer = Uint8Array.from([...this.buffer, ...buf]);
  }
};

// src/utils/leb128/unsigned.ts
var unsigned_exports = {};
__export(unsigned_exports, {
  decode: () => decode2,
  encode: () => encode2,
  read: () => read,
  readBigInt: () => readBigInt,
  write: () => write
});
function read(stream) {
  return readBigInt(stream).toString();
}
function readBigInt(stream) {
  let num = 0n;
  let shift = 0;
  let byte;
  while (true) {
    byte = stream.read(1)[0];
    num |= BigInt(byte & 127) << BigInt(shift);
    if ((byte & 128) === 0) {
      break;
    }
    shift += 7;
  }
  return num;
}
function write(number, stream) {
  let num = BigInt(number);
  while (true) {
    const i = Number(num & 0x7fn);
    num >>= 7n;
    if (num === 0n) {
      stream.write(new Uint8Array([i]));
      break;
    } else {
      stream.write(new Uint8Array([i | 128]));
    }
  }
}
function encode2(num) {
  const stream = new Stream();
  write(num, stream);
  return stream.buffer;
}
function decode2(buffer) {
  const stream = new Stream(buffer);
  return read(stream);
}

// src/address/errors.ts
var InvalidProtocolIndicator = class extends Error {
  constructor(value) {
    super();
    this.message = `Invalid protocol indicator byte [${value}]`;
  }
};
var UnknownProtocolIndicator = class extends Error {
  constructor(value) {
    super();
    this.message = `Unknown protocol indicator byte [${value}]`;
  }
};
var InvalidPayloadLength = class extends Error {
  constructor(len) {
    super();
    this.message = `Invalid payload length [${len}]`;
  }
};
var InvalidNamespace = class extends Error {
  constructor(value) {
    super();
    this.message = `Invalid namespace [${value}]`;
  }
};
var InvalidNetwork = class extends Error {
  constructor(value) {
    super();
    this.message = `Invalid network [${value}]`;
  }
};
var InvalidSubAddress = class extends Error {
  constructor() {
    super();
    this.message = "Invalid subAddress.";
  }
};
var InvalidId = class extends Error {
  constructor(id) {
    super();
    this.message = `Invalid id [${id}]`;
  }
};
var InvalidChecksumAddress = class extends Error {
  constructor(checksum1, checksum2) {
    super();
    this.message = `Invalid address (checksum not matching the payload). ${checksum1} vs ${checksum2}`;
  }
};

// src/address/index.ts
var Address = class _Address {
  /**
   *
   * @param protocol - indicates the address types.
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(protocol, networkPrefix) {
    this.protocol = protocol;
    this.networkPrefix = networkPrefix;
  }
  /**
   * Getter for payload
   */
  getPayload = () => this.payload;
  /**
   * Getter for network type
   */
  getNetworkPrefix = () => this.networkPrefix;
  /**
   * Getter for protocol indicator
   */
  getProtocol = () => this.protocol;
  /**
   * Allows to generate the checksum related to the address.
   * For more information about string format, please refer to this {@link https://spec.filecoin.io/appendix/address/#section-appendix.address.checksum|link}.
   * @returns a buffer containing the calculated checksum
   */
  getChecksum = () => getChecksum(this.toBytes());
  /**
   * Allows to parse any address from string format to its corresponding type
   * @param address - address to parse in string format
   * @returns a new instance of a particular address type.
   */
  static fromString(address) {
    if (address.length === 0) throw new Error("Invalid address");
    const indicator = address[1];
    if (indicator === void 0) throw new Error("Invalid network prefix");
    const type = parseInt(indicator);
    switch (type) {
      case 0 /* ID */:
        return AddressId.fromString(address);
      case 2 /* ACTOR */:
        return AddressActor.fromString(address);
      case 1 /* SECP256K1 */:
        return AddressSecp256k1.fromString(address);
      case 3 /* BLS */:
        return AddressBls.fromString(address);
      case 4 /* DELEGATED */: {
        const addr = AddressDelegated.fromString(address);
        if (_Address.isFilEthAddress(addr))
          return new FilEthAddress(
            addr.getSubAddress(),
            addr.getNetworkPrefix()
          );
        return addr;
      }
      default:
        throw new UnknownProtocolIndicator(type);
    }
  }
  /**
   * Allows to parse any address from bytes format to its corresponding type
   * @param address - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of a particular address type.
   */
  static fromBytes = (address, networkPrefix = "t" /* Testnet */) => {
    const type = address[0];
    if (type === void 0) throw new Error("Invalid address");
    switch (type) {
      case 0 /* ID */:
        return AddressId.fromBytes(address, networkPrefix);
      case 2 /* ACTOR */:
        return AddressActor.fromBytes(address, networkPrefix);
      case 1 /* SECP256K1 */:
        return AddressSecp256k1.fromBytes(address, networkPrefix);
      case 3 /* BLS */:
        return AddressBls.fromBytes(address, networkPrefix);
      case 4 /* DELEGATED */: {
        const addr = AddressDelegated.fromBytes(address, networkPrefix);
        if (_Address.isFilEthAddress(addr))
          return new FilEthAddress(
            addr.getSubAddress(),
            addr.getNetworkPrefix()
          );
        return addr;
      }
      default:
        throw new UnknownProtocolIndicator(type);
    }
  };
  /**
   * Allows to create a new instance of an Address from an ethereum address.
   * It is based on {@link https://github.com/filecoin-project/lotus/blob/80aa6d1d646c9984761c77dcb7cf63be094b9407/chain/types/ethtypes/eth_types.go#L370|this code}
   * @param ethAddr - ethereum address to parse (buffer or hex string, with or without prefix)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of a particular address type.
   */
  static fromEthAddress = (ethAddr, networkPrefix = "t" /* Testnet */) => {
    let addr;
    if (typeof ethAddr === "string") {
      const tmp = ethAddr.startsWith("0x") ? ethAddr.substring(2) : ethAddr;
      if (tmp.length % 2 !== 0) {
        throw new Error("invalid eth address");
      }
      addr = (0, import_from_string2.fromString)(tmp.toLowerCase(), "hex");
    } else {
      addr = ethAddr;
    }
    if (isMaskedIdEthAddress(addr)) {
      let i = ACTOR_ID_ETHEREUM_MASK_LEN;
      while (addr[i] == 0) i += 1;
      const payload = unsigned_exports.encode(
        "0x" + (0, import_to_string.toString)(addr.subarray(i), "hex")
      );
      return new AddressId(payload, networkPrefix);
    }
    return new FilEthAddress(addr, networkPrefix);
  };
  /**
   * Allows to check if true value of an address instance is AddressId
   * @param address - instance to check its actual type
   * @returns whether the instance is AddressId or not
   */
  static isAddressId = (address) => address.protocol == 0 /* ID */;
  /**
   * Allows to check if true value of an address instance is AddressBls
   * @param address - instance to check its actual type
   * @returns whether the instance is AddressId or not
   */
  static isAddressBls = (address) => address.protocol == 3 /* BLS */;
  /**
   * Allows to check if true value of an address instance is AddressSecp256k1
   * @param address - instance to check its actual type
   * @returns whether the instance is AddressSecp256k1 or not
   */
  static isAddressSecp256k1 = (address) => address.protocol == 1 /* SECP256K1 */;
  /**
   * Allows to check if true value of an address instance is AddressDelegated
   * @param address - instance to check its actual type
   * @returns whether the instance is AddressDelegated or not
   */
  static isAddressDelegated = (address) => address.protocol == 4 /* DELEGATED */;
  /**
   * Allows to check if true value of an address instance is FilEthAddress
   * @param address - instance to check its actual type
   * @returns whether the instance is FilEthAddress or not
   */
  static isFilEthAddress = (address) => address.protocol == 4 /* DELEGATED */ && "namespace" in address && address.namespace == "10" /* ETH */;
  /**
   * Allows to check if true value of an address instance is AddressActor
   * @param address - instance to check its actual type
   * @returns whether the instance is AddressActor or not
   */
  static isAddressActor = (address) => address.protocol == 2 /* ACTOR */;
};
var AddressBls = class _AddressBls extends Address {
  /**
   * Contains BLS public key, base32 encoded
   * For more information about payloads, please refer to this {@link https://spec.filecoin.io/appendix/address/#section-appendix.address.payload|link}.
   */
  payload;
  /**
   * Allows to create a new instance of bls address
   * @param payload - current address payload (buffer)
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(payload, networkPrefix = "t" /* Testnet */) {
    super(3 /* BLS */, networkPrefix);
    if (payload.byteLength !== BLS_PAYLOAD_LEN)
      throw new InvalidPayloadLength(payload.byteLength);
    this.payload = payload;
  }
  /**
   * Allows to get the bytes format of this address
   * @returns bls address in bytes format
   */
  toBytes = () => (0, import_concat.concat)([new Uint8Array([this.protocol]), this.payload]);
  /**
   * Allows to get the string format of this address
   * @returns bls address in string format
   */
  toString = () => {
    const checksum = this.getChecksum();
    return this.networkPrefix + this.protocol.toString() + encode((0, import_concat.concat)([this.payload, checksum])).toLowerCase();
  };
  /**
   * Allows to create a new AddressBls instance from a string
   * @param address - address in string format
   * @returns a new instance of AddressBls
   */
  static fromString(address) {
    const networkPrefix = address[0];
    const protocolIndicator = address[1];
    if (!networkPrefix) throw new Error("Invalid network prefix");
    if (protocolIndicator === void 0)
      throw new Error("Invalid protocol indicator");
    if (!validateNetworkPrefix(networkPrefix))
      throw new InvalidNetwork(networkPrefix);
    if (parseInt(protocolIndicator) != 3 /* BLS */)
      throw new InvalidProtocolIndicator(parseInt(protocolIndicator));
    const decodedData = new Uint8Array(
      decode(address.substring(2).toUpperCase())
    );
    const payload = decodedData.subarray(0, -4);
    const checksum = decodedData.subarray(-4);
    const newAddress = new _AddressBls(payload, networkPrefix);
    const addressChecksum = (0, import_to_string.toString)(newAddress.getChecksum(), "hex");
    const originalChecksum = (0, import_to_string.toString)(checksum, "hex");
    if (addressChecksum !== originalChecksum)
      throw new InvalidChecksumAddress(addressChecksum, originalChecksum);
    return newAddress;
  }
  /**
   * Allows to create a new AddressBls instance from bytes (buffer)
   * @param bytes - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of AddressBls
   */
  static fromBytes(bytes, networkPrefix = "t" /* Testnet */) {
    const indicator = bytes[0];
    if (indicator === void 0) throw new Error("Invalid protocol indicator");
    if (indicator != 3 /* BLS */)
      throw new InvalidProtocolIndicator(indicator);
    const payload = bytes.subarray(1);
    return new _AddressBls(payload, networkPrefix);
  }
};
var AddressId = class _AddressId extends Address {
  /**
   * Contains the id in decimal
   */
  id;
  /**
   * Contains leb128 encoded id
   * For more information about payloads, please refer to this {@link https://spec.filecoin.io/appendix/address/#section-appendix.address.payload|link}.
   */
  payload;
  /**
   * Allows to create a new instance of id address
   * @param payload - current address payload. It can be string (id in decimal) or buffer (leb128 encoded id)
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(payload, networkPrefix = "t" /* Testnet */) {
    super(0 /* ID */, networkPrefix);
    let payloadBuff;
    if (typeof payload === "string") {
      payloadBuff = unsigned_exports.encode(payload);
    } else {
      payloadBuff = unsigned_exports.encode(unsigned_exports.decode(payload));
      if ((0, import_compare2.compare)(payloadBuff, payload) !== 0) {
        throw new Error("invalid leb128 encoded payload");
      }
    }
    const idNum = BigInt(unsigned_exports.decode(payloadBuff));
    if (idNum > ID_PAYLOAD_MAX_NUM) throw new InvalidId(idNum.toString());
    this.payload = payloadBuff;
    this.id = this.toString().substring(2);
  }
  /**
   * Allows to get the bytes format of this address
   * @returns id address in bytes format
   */
  toBytes = () => {
    return (0, import_concat.concat)([new Uint8Array([this.protocol]), this.payload]);
  };
  /**
   * Allows to get the string format of this address
   * @returns id address in string format
   */
  toString = () => this.networkPrefix + this.protocol.toString() + unsigned_exports.decode(this.payload);
  /**
   * Getter for actor id
   */
  getId = () => this.id;
  /**
   * Allows to create a new AddressId instance from a string
   * @param address - address in string format
   * @returns a new instance of AddressId
   */
  static fromString(address) {
    const networkPrefix = address[0];
    const protocolIndicator = address[1];
    if (!networkPrefix) throw new Error("Invalid network prefix");
    if (protocolIndicator === void 0)
      throw new Error("Invalid protocol indicator");
    if (!validateNetworkPrefix(networkPrefix))
      throw new InvalidNetwork(networkPrefix);
    if (parseInt(protocolIndicator) != 0 /* ID */)
      throw new InvalidProtocolIndicator(parseInt(protocolIndicator));
    const payload = unsigned_exports.encode(address.substring(2));
    return new _AddressId(payload, networkPrefix);
  }
  /**
   * Allows to create a new AddressId instance from bytes (buffer)
   * @param bytes - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of AddressId
   */
  static fromBytes(bytes, networkPrefix = "t" /* Testnet */) {
    const indicator = bytes[0];
    if (indicator === void 0) throw new Error("Invalid protocol indicator");
    if (indicator != 0 /* ID */)
      throw new InvalidProtocolIndicator(indicator);
    const payload = bytes.subarray(1);
    return new _AddressId(payload, networkPrefix);
  }
  /**
   * Allows to get an ethereum address that holds the actor id
   * @param hexPrefix - add the 0x prefix or not
   * @returns ethereum address
   */
  toEthAddressHex = (hexPrefix = true) => {
    const buf = new Uint8Array(ETH_ADDRESS_LEN);
    buf[0] = ACTOR_ID_ETHEREUM_MASK;
    const decodedPayload = bigintToUint8Array(unsigned_exports.decode(this.payload));
    buf.set(decodedPayload, ETH_ADDRESS_LEN - decodedPayload.byteLength);
    return `${hexPrefix ? "0x" : ""}${(0, import_to_string.toString)(buf, "hex")}`;
  };
};
var AddressSecp256k1 = class _AddressSecp256k1 extends Address {
  /**
   * Contains the Blake2b 160 hash of the uncompressed public key (65 bytes).
   * For more information about payloads, please refer to this {@link https://spec.filecoin.io/appendix/address/#section-appendix.address.payload|link}.
   */
  payload;
  /**
   * Allows to create a new instance of secp256k1 address
   * @param payload - current address payload (buffer)
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(payload, networkPrefix = "t" /* Testnet */) {
    super(1 /* SECP256K1 */, networkPrefix);
    if (payload.byteLength !== SECP256K1_PAYLOAD_LEN)
      throw new InvalidPayloadLength(payload.byteLength);
    this.payload = payload;
  }
  /**
   * Allows to get the bytes format of this address
   * @returns secp256k1 address in bytes format
   */
  toBytes = () => (0, import_concat.concat)([new Uint8Array([this.protocol]), this.payload]);
  /**
   * Allows to get the string format of this address
   * @returns secp256k1 address in string format
   */
  toString = () => {
    const checksum = this.getChecksum();
    return this.networkPrefix + this.protocol.toString() + encode((0, import_concat.concat)([this.payload, checksum])).toLowerCase();
  };
  /**
   * Allows to create a new AddressSecp256k1 instance from a string
   * @param address - address in string format
   * @returns a new instance of AddressSecp256k1
   */
  static fromString(address) {
    const networkPrefix = address[0];
    const protocolIndicator = address[1];
    if (!networkPrefix) throw new Error("Invalid network prefix");
    if (protocolIndicator === void 0)
      throw new Error("Invalid protocol indicator");
    if (!validateNetworkPrefix(networkPrefix))
      throw new InvalidNetwork(networkPrefix);
    if (parseInt(protocolIndicator) != 1 /* SECP256K1 */)
      throw new InvalidProtocolIndicator(parseInt(protocolIndicator));
    const decodedData = new Uint8Array(
      decode(address.substring(2).toUpperCase())
    );
    const payload = decodedData.subarray(0, -4);
    const checksum = decodedData.subarray(-4);
    const newAddress = new _AddressSecp256k1(payload, networkPrefix);
    const addressChecksum = (0, import_to_string.toString)(newAddress.getChecksum(), "hex");
    const originalChecksum = (0, import_to_string.toString)(checksum, "hex");
    if (addressChecksum !== originalChecksum)
      throw new InvalidChecksumAddress(addressChecksum, originalChecksum);
    return newAddress;
  }
  /**
   * Allows to create a new AddressSecp256k1 instance from bytes (buffer)
   * @param bytes - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of AddressSecp256k1
   */
  static fromBytes(bytes, networkPrefix = "t" /* Testnet */) {
    const indicator = bytes[0];
    if (indicator === void 0) throw new Error("Invalid protocol indicator");
    if (indicator != 1 /* SECP256K1 */)
      throw new InvalidProtocolIndicator(indicator);
    const payload = bytes.subarray(1);
    return new _AddressSecp256k1(payload, networkPrefix);
  }
};
var AddressActor = class _AddressActor extends Address {
  /**
   * Contains the SHA256 hash of meaningful data produced as a result of creating the actor
   * For more information about payloads, please refer to this {@link https://spec.filecoin.io/appendix/address/#section-appendix.address.payload|link}.
   */
  payload;
  /**
   * Allows to create a new instance of actor address
   * @param payload - current address payload (buffer)
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(payload, networkPrefix = "t" /* Testnet */) {
    super(2 /* ACTOR */, networkPrefix);
    if (payload.byteLength !== ACTOR_PAYLOAD_LEN)
      throw new InvalidPayloadLength(payload.byteLength);
    this.payload = payload;
  }
  /**
   * Allows to get the bytes format of this address
   * @returns actor address in bytes format
   */
  toBytes = () => (0, import_concat.concat)([new Uint8Array([this.protocol]), this.payload]);
  /**
   * Allows to get the string format of this address
   * @returns actor address in string format
   */
  toString = () => {
    const checksum = this.getChecksum();
    return this.networkPrefix + this.protocol.toString() + encode((0, import_concat.concat)([this.payload, checksum])).toLowerCase();
  };
  /**
   * Allows to create a new AddressActor instance from a string
   * @param address - address in string format
   * @returns a new instance of AddressActor
   */
  static fromString(address) {
    const networkPrefix = address[0];
    const protocolIndicator = address[1];
    if (!networkPrefix) throw new Error("Invalid network prefix");
    if (protocolIndicator === void 0)
      throw new Error("Invalid protocol indicator");
    if (!validateNetworkPrefix(networkPrefix))
      throw new InvalidNetwork(networkPrefix);
    if (parseInt(protocolIndicator) != 2 /* ACTOR */)
      throw new InvalidProtocolIndicator(parseInt(protocolIndicator));
    const decodedData = new Uint8Array(
      decode(address.substring(2).toUpperCase())
    );
    const payload = decodedData.subarray(0, -4);
    const checksum = decodedData.subarray(-4);
    const newAddress = new _AddressActor(payload, networkPrefix);
    const addressChecksum = (0, import_to_string.toString)(newAddress.getChecksum(), "hex");
    const originalChecksum = (0, import_to_string.toString)(checksum, "hex");
    if (addressChecksum !== originalChecksum)
      throw new InvalidChecksumAddress(addressChecksum, originalChecksum);
    return newAddress;
  }
  /**
   * Allows to create a new AddressActor instance from bytes (buffer)
   * @param bytes - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of AddressActor
   */
  static fromBytes(bytes, networkPrefix = "t" /* Testnet */) {
    const indicator = bytes[0];
    if (indicator === void 0) throw new Error("Invalid protocol indicator");
    if (indicator != 2 /* ACTOR */)
      throw new InvalidProtocolIndicator(indicator);
    const payload = bytes.subarray(1);
    return new _AddressActor(payload, networkPrefix);
  }
};
var AddressDelegated = class _AddressDelegated extends Address {
  /**
   * Contains the address manager actor id (leb128 encoded) and the subaddress (plain)
   * For more information about payloads, please refer to this {@link https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0048.md#the-f4-address-class|link}.
   */
  payload;
  /**
   * Contains the address manager actor id (decimal)
   */
  namespace;
  /**
   * Contains the sub address (plain)
   */
  subAddress;
  /**
   * Allows to create a new instance of delegated address
   * @param namespace - account manager actor id
   * @param subAddress - user-defined address the account manager will know and administrate (buffer)
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(namespace, subAddress, networkPrefix = "t" /* Testnet */) {
    super(4 /* DELEGATED */, networkPrefix);
    if (BigInt(namespace) > ID_PAYLOAD_MAX_NUM)
      throw new InvalidNamespace(namespace);
    if (subAddress.length === 0 || subAddress.length > SUB_ADDRESS_MAX_LEN)
      throw new InvalidSubAddress();
    if (namespace === "10" /* ETH */ && isMaskedIdEthAddress(subAddress)) {
      throw new Error("masked-id eth addresses not allowed");
    }
    this.namespace = namespace;
    this.subAddress = subAddress;
    this.payload = this.toBytes().subarray(1);
  }
  /**
   * Getter for namespace
   */
  getNamespace = () => this.namespace;
  /**
   * Getter for sub address
   */
  getSubAddress = () => this.subAddress;
  /**
   * Allows to get the bytes format of this address
   * @returns delegated address in bytes format
   */
  toBytes = () => {
    const namespaceBytes = unsigned_exports.encode(this.namespace);
    const protocolBytes = unsigned_exports.encode(this.protocol);
    return (0, import_concat.concat)([protocolBytes, namespaceBytes, this.subAddress]);
  };
  /**
   * Allows to get the string format of this address
   * @returns delegated address in string format
   */
  toString = () => {
    const checksum = this.getChecksum();
    return this.networkPrefix + this.protocol.toString() + this.namespace + "f" + encode((0, import_concat.concat)([this.subAddress, checksum])).toLowerCase();
  };
  /**
   * Allows to create a new AddressDelegated instance from a string
   * @param address - address in string format
   * @returns a new instance of AddressDelegated
   */
  static fromString(address) {
    const networkPrefix = address[0];
    const protocolIndicator = address[1];
    if (!networkPrefix) throw new Error("Invalid network prefix");
    if (protocolIndicator === void 0)
      throw new Error("Invalid protocol indicator");
    if (!validateNetworkPrefix(networkPrefix))
      throw new InvalidNetwork(networkPrefix);
    if (parseInt(protocolIndicator) != 4 /* DELEGATED */)
      throw new InvalidProtocolIndicator(parseInt(protocolIndicator));
    const namespace = address.substring(2, address.indexOf("f", 2));
    const dataEncoded = address.substring(address.indexOf("f", 2) + 1);
    const dataDecoded = new Uint8Array(decode(dataEncoded.toUpperCase()));
    const subAddress = dataDecoded.subarray(0, -4);
    const checksum = dataDecoded.subarray(-4);
    const newAddress = new _AddressDelegated(
      namespace,
      subAddress,
      networkPrefix
    );
    const addressChecksum = (0, import_to_string.toString)(newAddress.getChecksum(), "hex");
    const originalChecksum = (0, import_to_string.toString)(checksum, "hex");
    if (addressChecksum !== originalChecksum)
      throw new InvalidChecksumAddress(addressChecksum, originalChecksum);
    return newAddress;
  }
  /**
   * Allows to create a new AddressDelegated instance from bytes (buffer)
   * @param bytes - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of AddressDelegated
   */
  static fromBytes(bytes, networkPrefix = "t" /* Testnet */) {
    const indicator = bytes[0];
    if (indicator === void 0) throw new Error("Invalid protocol indicator");
    if (indicator != 4 /* DELEGATED */)
      throw new InvalidProtocolIndicator(indicator);
    const namespaceLength = getLeb128Length(bytes.subarray(1));
    const namespace = unsigned_exports.decode(bytes.subarray(1, 1 + namespaceLength));
    const subAddress = bytes.subarray(namespaceLength + 1);
    return new _AddressDelegated(namespace, subAddress, networkPrefix);
  }
};
var FilEthAddress = class _FilEthAddress extends AddressDelegated {
  /**
   * Allows to create a new instance of EthereumAddress
   * @param ethAddress - valid ethereum address to wrap (as buffer)
   * @param networkPrefix - indicates which network the address belongs.
   */
  constructor(ethAddress, networkPrefix = "t" /* Testnet */) {
    super("10" /* ETH */, ethAddress, networkPrefix);
    if (ethAddress.length !== ETH_ADDRESS_LEN)
      throw new Error(
        `invalid ethereum address: length should be ${ETH_ADDRESS_LEN} bytes`
      );
    if (isMaskedIdEthAddress(ethAddress))
      throw new Error("masked-id eth addresses not allowed");
  }
  /**
   * Allows to create a new EthereumAddress instance from filecoin address in bytes format (buffer)
   * @example networkPrefix: 'f' - bytesFilAddress: 040a23a7f3c5c663d71151f40c8610c01150c9660795
   * @param bytesFilAddress - address to parse in bytes format (buffer)
   * @param networkPrefix - indicates which network the address belongs, as the bytes format does not hold the network the address corresponds
   * @returns a new instance of EthereumAddress
   */
  static fromBytes(bytesFilAddress, networkPrefix = "t" /* Testnet */) {
    const addr = AddressDelegated.fromBytes(bytesFilAddress, networkPrefix);
    if (addr.getNamespace() !== "10" /* ETH */)
      throw new Error("invalid filecoin address for ethereum space");
    return new _FilEthAddress(addr.getSubAddress(), addr.getNetworkPrefix());
  }
  /**
   * Allows to create a new EthereumAddress instance from filecoin address in string format
   * @param strFilAddress - address to parse in string format (buffer)
   * @example strFilAddress: f410feot7hrogmplrcupubsdbbqarkdewmb4vkwc5qqq
   * @returns a new instance of EthereumAddress
   */
  static fromString(strFilAddress) {
    const addr = AddressDelegated.fromString(strFilAddress);
    if (addr.getNamespace() !== "10" /* ETH */)
      throw new Error("invalid filecoin address for ethereum space");
    return new _FilEthAddress(addr.getSubAddress(), addr.getNetworkPrefix());
  }
  /**
   * Allows to get the ethereum address in hex format of this address
   * @param hexPrefix - add the 0x prefix or not. Defaults to true.
   * @returns ethereum address in hex string format
   */
  toEthAddressHex = (hexPrefix = true) => `${hexPrefix ? "0x" : ""}${(0, import_to_string.toString)(this.subAddress, "hex")}`;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Address,
  AddressActor,
  AddressBls,
  AddressDelegated,
  AddressId,
  AddressSecp256k1,
  FilEthAddress
});
