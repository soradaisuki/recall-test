"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/provider.ts
var provider_exports = {};
__export(provider_exports, {
  callObjectsApiAddObject: () => callObjectsApiAddObject,
  createObjectsFormData: () => createObjectsFormData,
  downloadBlob: () => downloadBlob,
  getObjectsNodeInfo: () => getObjectsNodeInfo
});
module.exports = __toCommonJS(provider_exports);
var import_address3 = require("@recallnet/fvm/address");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var BucketNotFound = class extends Error {
  constructor(bucket) {
    super(`Bucket not found: '${bucket}'`);
    this.name = "BucketNotFound";
  }
};
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var ObjectNotAvailable = class extends Error {
  constructor(key, blobHash) {
    super(
      `Object not available: unrecoverable key '${key}' with blob hash '${blobHash}'`
    );
    this.name = "ObjectNotAvailable";
  }
};
var UnhandledBucketError = class extends Error {
  constructor(message) {
    super(`Bucket error: ${message}`);
    this.name = "UnhandledBucketError";
  }
};

// src/utils.ts
var import_viem = require("viem");
var import_viem2 = require("viem");
var import_address2 = require("@recallnet/fvm/address");
var import_utils = require("@recallnet/fvm/utils");
function snakeToCamel(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),
      value
    ])
  );
}

// src/provider.ts
function createObjectsFormData({
  data,
  size,
  contentType
}) {
  const formData = new FormData();
  formData.append("size", size.toString());
  formData.append(
    "data",
    new File([data], "blob", {
      type: contentType ?? "application/octet-stream"
    })
  );
  return formData;
}
async function getObjectsNodeInfo(objectsProviderUrl) {
  const response = await fetch(`${objectsProviderUrl}/v1/node`);
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function callObjectsApiAddObject(objectsProviderUrl, data, size, contentType) {
  const formData = createObjectsFormData({
    data,
    size,
    contentType
  });
  const response = await fetch(`${objectsProviderUrl}/v1/objects`, {
    method: "POST",
    body: formData
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function downloadBlob(objectsProviderUrl, bucket, key, range, blockNumber) {
  const headers = {};
  if (range) {
    headers.Range = `bytes=${range.start ?? ""}-${range.end ?? ""}`;
  }
  const bucketIdAddress = import_address3.AddressId.fromEthAddress(bucket);
  const url = new URL(
    `${objectsProviderUrl}/v1/objects/${bucketIdAddress}/${key}`
  );
  if (blockNumber !== void 0) {
    url.searchParams.set("height", blockNumber.toString());
  }
  const response = await fetch(url, {
    headers
  });
  if (!response.ok) {
    const error = await response.json();
    if (error.message.includes("actor does not exist")) {
      throw new BucketNotFound(bucket);
    }
    if (error.message.includes("is not available")) {
      const blobHash = error.message.match(/object\s+(.*)\s+is not available/)?.[1] ?? "";
      throw new ObjectNotAvailable(key, blobHash);
    }
    if (error.message.includes("invalid range header")) {
      throw new InvalidValue(
        `Invalid range: ${range?.start ?? ""}-${range?.end ?? ""}`
      );
    }
    throw new UnhandledBucketError(
      `Failed to download object: ${error.message}`
    );
  }
  if (!response.body) {
    throw new UnhandledBucketError("Failed to download object: no body");
  }
  return response.body;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  callObjectsApiAddObject,
  createObjectsFormData,
  downloadBlob,
  getObjectsNodeInfo
});
