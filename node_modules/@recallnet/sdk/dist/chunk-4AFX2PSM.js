import {
  snakeToCamel
} from "./chunk-DLYT7DCU.js";
import {
  BucketNotFound,
  InvalidValue,
  ObjectNotAvailable,
  UnhandledBucketError
} from "./chunk-VDEK3UW2.js";

// src/provider.ts
import { AddressId } from "@recallnet/fvm/address";
function createObjectsFormData({
  data,
  size,
  contentType
}) {
  const formData = new FormData();
  formData.append("size", size.toString());
  formData.append(
    "data",
    new File([data], "blob", {
      type: contentType ?? "application/octet-stream"
    })
  );
  return formData;
}
async function getObjectsNodeInfo(objectsProviderUrl) {
  const response = await fetch(`${objectsProviderUrl}/v1/node`);
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function callObjectsApiAddObject(objectsProviderUrl, data, size, contentType) {
  const formData = createObjectsFormData({
    data,
    size,
    contentType
  });
  const response = await fetch(`${objectsProviderUrl}/v1/objects`, {
    method: "POST",
    body: formData
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function downloadBlob(objectsProviderUrl, bucket, key, range, blockNumber) {
  const headers = {};
  if (range) {
    headers.Range = `bytes=${range.start ?? ""}-${range.end ?? ""}`;
  }
  const bucketIdAddress = AddressId.fromEthAddress(bucket);
  const url = new URL(
    `${objectsProviderUrl}/v1/objects/${bucketIdAddress}/${key}`
  );
  if (blockNumber !== void 0) {
    url.searchParams.set("height", blockNumber.toString());
  }
  const response = await fetch(url, {
    headers
  });
  if (!response.ok) {
    const error = await response.json();
    if (error.message.includes("actor does not exist")) {
      throw new BucketNotFound(bucket);
    }
    if (error.message.includes("is not available")) {
      const blobHash = error.message.match(/object\s+(.*)\s+is not available/)?.[1] ?? "";
      throw new ObjectNotAvailable(key, blobHash);
    }
    if (error.message.includes("invalid range header")) {
      throw new InvalidValue(
        `Invalid range: ${range?.start ?? ""}-${range?.end ?? ""}`
      );
    }
    throw new UnhandledBucketError(
      `Failed to download object: ${error.message}`
    );
  }
  if (!response.body) {
    throw new UnhandledBucketError("Failed to download object: no body");
  }
  return response.body;
}

export {
  createObjectsFormData,
  getObjectsNodeInfo,
  callObjectsApiAddObject,
  downloadBlob
};
