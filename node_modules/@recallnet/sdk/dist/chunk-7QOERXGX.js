import {
  InsufficientFunds,
  UnhandledGatewayError
} from "./chunk-VDEK3UW2.js";

// src/ipc/gateway.ts
import {
  ContractFunctionExecutionError,
  getContract,
  toHex
} from "viem";
import { gatewayManagerFacetAbi } from "@recallnet/contracts";
import { AddressDelegated } from "@recallnet/fvm/address";
function addressToFvmAddressTyped(address) {
  const addr = AddressDelegated.fromEthAddress(address);
  return { addrType: addr.getProtocol(), payload: toHex(addr.getPayload()) };
}
function fundParamsToTyped(address, subnetId, amount) {
  const fvmAddress = addressToFvmAddressTyped(address);
  const subnet = {
    root: BigInt(subnetId.evm.root),
    route: subnetId.evm.route
  };
  return [subnet, fvmAddress, amount];
}
function releaseParamsToTyped(address) {
  const fvmAddress = addressToFvmAddressTyped(address);
  return [fvmAddress];
}
var GatewayManager = class {
  getContract(publicClient, walletClient, contractAddress) {
    const chainId = publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    return getContract({
      abi: gatewayManagerFacetAbi,
      address: contractAddress,
      client: {
        public: publicClient,
        wallet: walletClient
      }
    });
  }
  // Fund gateway with tokens. Assumes the request is coming from the parent chain for a specific
  // child chain (identified by the subnet ID).
  async fundWithToken(publicClient, walletClient, contractAddress, forSubnet, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for funding gateway");
    }
    try {
      const recipientAddress = recipient || walletClient.account.address;
      const args = fundParamsToTyped(recipientAddress, forSubnet, amount);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.fundWithToken(args, {
        account: walletClient.account,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        if (error.message.includes("insufficient funds")) {
          throw new InsufficientFunds(amount);
        }
      }
      throw new UnhandledGatewayError(`Failed to fund gateway: ${error}`);
    }
  }
  // Release funds from gateway (child chain to parent chain)
  async release(publicClient, walletClient, contractAddress, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for releasing funds");
    }
    try {
      const address = recipient || walletClient.account.address;
      const args = releaseParamsToTyped(address);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.release(args, {
        account: walletClient.account,
        value: amount,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledGatewayError(`Failed to release funds: ${error}`);
    }
  }
};

export {
  GatewayManager
};
