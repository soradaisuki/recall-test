"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/entities/blob.ts
var blob_exports = {};
__export(blob_exports, {
  BlobManager: () => BlobManager
});
module.exports = __toCommonJS(blob_exports);
var import_viem3 = require("viem");
var import_chains = require("@recallnet/chains");
var import_contracts = require("@recallnet/contracts");
var import_network_constants = require("@recallnet/network-constants");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var UnhandledBlobError = class extends Error {
  constructor(message) {
    super(`Blob error: ${message}`);
    this.name = "UnhandledBlobError";
  }
};
function isActorNotFoundError(error) {
  const isActorNotFound = error.message.includes(
    "actor::resolve_address -- actor not found"
  );
  const addressMatch = error.message.match(/f410[a-z0-9]+/i);
  return {
    isActorNotFound,
    address: addressMatch ? import_address.FilEthAddress.fromString(addressMatch[0]).toEthAddressHex() : null
  };
}
var ActorNotFound = class extends Error {
  constructor(address) {
    super(
      `Actor not found (hint: ensure the address is registered: '${address}')`
    );
    this.name = "ActorNotFound";
  }
};

// src/provider.ts
var import_address3 = require("@recallnet/fvm/address");

// src/utils.ts
var import_viem = require("viem");
var import_viem2 = require("viem");
var import_address2 = require("@recallnet/fvm/address");
var import_utils = require("@recallnet/fvm/utils");
function snakeToCamel(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),
      value
    ])
  );
}

// src/provider.ts
async function getObjectsNodeInfo(objectsProviderUrl) {
  const response = await fetch(`${objectsProviderUrl}/v1/node`);
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}

// src/entities/blob.ts
var BlobManager = class {
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedBlobManagerAddress = import_contracts.blobManagerAddress[chainId];
    if (!deployedBlobManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = (0, import_viem3.getContract)({
      abi: import_contracts.blobManagerAbi,
      address: contractAddress || deployedBlobManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
  }
  getContract() {
    return this.contract;
  }
  // Add blob inner
  async addBlobInner(addParams) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding blobs");
    }
    try {
      const args = [addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.addBlob(
        args,
        {
          account: this.client.walletClient.account,
          gasPrice
        }
      );
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to add blob: ${error}`);
    }
  }
  // Add blob
  // TODO: this assumes the blob already exists on the network; there's no way to upload raw blobs
  // to the objects API (it requires a bucket and a key)
  async addBlob(blobHash, subscriptionId, size, options = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding blobs");
    }
    const ttl = options?.ttl ?? 0n;
    if (ttl !== 0n && ttl < import_network_constants.MIN_TTL) {
      throw new InvalidValue(`TTL must be at least ${import_network_constants.MIN_TTL} seconds`);
    }
    const objectApiUrl = (0, import_chains.getObjectApiUrl)(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    const from = this.client.walletClient.account.address;
    const addParams = {
      sponsor: options.sponsor ?? import_viem3.zeroAddress,
      source,
      blobHash,
      metadataHash: "",
      subscriptionId,
      size,
      ttl,
      from
    };
    return this.addBlobInner(addParams);
  }
  // Delete blob
  async deleteBlob(blobHash, subscriptionId, subscriber) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for deleting blobs");
    }
    try {
      const from = this.client.walletClient.account.address;
      const args = [
        subscriber || import_viem3.zeroAddress,
        blobHash,
        subscriptionId,
        from
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.deleteBlob(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to delete blob: ${error}`);
    }
  }
  // Get blob info
  // TODO: there's no way to download raw blobs from the objects API (it requires a bucket and a key)
  async getBlob(blobHash, blockNumber) {
    try {
      const args = [blobHash];
      const result = await this.contract.read.getBlob(args, { blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get blob info: ${error}`);
    }
  }
  // Get blob status
  async getBlobStatus(subscriber, blobHash, subscriptionId, blockNumber) {
    try {
      const args = [
        subscriber,
        blobHash,
        subscriptionId
      ];
      const result = await this.contract.read.getBlobStatus(args, {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to get blob status: ${error}`);
    }
  }
  // Overwrite blob inner
  async overwriteBlobInner(oldHash, addParams) {
    try {
      if (!this.client.walletClient?.account) {
        throw new Error(
          "Wallet client is not initialized for overwriting blobs"
        );
      }
      const params = [oldHash, addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.overwriteBlob(params, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to overwrite blob: ${error}`);
    }
  }
  // Overwrite blob
  async overwriteBlob(oldHash, newHash, subscriptionId, size, options = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for overwriting blobs");
    }
    const objectApiUrl = (0, import_chains.getObjectApiUrl)(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    const from = this.client.walletClient.account.address;
    const params = {
      sponsor: options.sponsor ?? import_viem3.zeroAddress,
      source,
      blobHash: newHash,
      metadataHash: "",
      subscriptionId,
      size,
      ttl: options.ttl ?? 0n,
      from
    };
    return this.overwriteBlobInner(oldHash, params);
  }
  // Get added blobs
  async getAddedBlobs(size, blockNumber) {
    try {
      const result = await this.contract.read.getAddedBlobs([size], {
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get added blobs: ${error}`);
    }
  }
  // Get pending blobs
  async getPendingBlobs(size, blockNumber) {
    try {
      const result = await this.contract.read.getPendingBlobs([size], {
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending blobs count: ${error}`
      );
    }
  }
  // Get pending blobs count
  async getPendingBlobsCount(blockNumber) {
    try {
      const result = await this.contract.read.getPendingBlobsCount({
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending blobs count: ${error}`
      );
    }
  }
  // Get pending bytes count
  async getPendingBytesCount(blockNumber) {
    try {
      const result = await this.contract.read.getPendingBytesCount({
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending bytes count: ${error}`
      );
    }
  }
  // Get storage stats
  async getStorageStats(blockNumber) {
    try {
      const result = await this.contract.read.getStorageStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get storage stats: ${error}`);
    }
  }
  // Get storage usage
  async getStorageUsage(address, blockNumber) {
    const addressArg = address || this.client.walletClient?.account?.address;
    if (!addressArg) {
      throw new Error("Address is required for getting storage usage");
    }
    try {
      const result = await this.contract.read.getStorageUsage([addressArg], {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound, address: address2 } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address2);
        }
      }
      throw new UnhandledBlobError(`Failed to get storage usage: ${error}`);
    }
  }
  // Get subnet stats
  async getSubnetStats(blockNumber) {
    try {
      const result = await this.contract.read.getSubnetStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get subnet stats: ${error}`);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BlobManager
});
