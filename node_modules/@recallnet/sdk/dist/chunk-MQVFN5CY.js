// src/ipc/subnet.ts
import fnv1a from "@sindresorhus/fnv1a";
import { FilEthAddress } from "@recallnet/fvm/address";
import {
  DEVNET_CHAIN_ID,
  DEVNET_SUBNET_ID,
  LOCALNET_CHAIN_ID,
  LOCALNET_SUBNET_ID,
  TESTNET_CHAIN_ID,
  TESTNET_SUBNET_ID
} from "@recallnet/network-constants";
var SubnetId = class _SubnetId {
  faux;
  real;
  // Uses FVM addresses
  evm;
  // Uses EVM addresses
  explicitChainId;
  constructor(root, route, chainId, faux = "") {
    this.real = {
      root,
      route
    };
    const evmRoute = route.length > 0 ? route.map((a) => FilEthAddress.fromString(a).toEthAddressHex()) : [];
    this.evm = {
      root,
      route: evmRoute
    };
    this.faux = faux;
    this.explicitChainId = chainId;
  }
  // Create a subnet ID from a string, like "/r31337/t410..."
  static fromString(subnetIdStr) {
    if (!subnetIdStr.toString().startsWith("/r")) {
      return new _SubnetId(0, [], void 0, subnetIdStr);
    }
    const [, rootRaw, routeRaw] = subnetIdStr.split("/");
    const root = Number(rootRaw?.slice(1));
    const route = routeRaw ? routeRaw.split("/") : [];
    let chainId;
    switch (subnetIdStr) {
      case TESTNET_SUBNET_ID:
        chainId = TESTNET_CHAIN_ID;
        break;
      case LOCALNET_SUBNET_ID:
        chainId = LOCALNET_CHAIN_ID;
        break;
      case DEVNET_SUBNET_ID:
        chainId = DEVNET_CHAIN_ID;
        break;
    }
    return new _SubnetId(root, route, chainId, subnetIdStr);
  }
  // Create a subnet ID from an official chain
  static fromChain(chain) {
    switch (chain.id) {
      case TESTNET_CHAIN_ID:
        return _SubnetId.fromString(TESTNET_SUBNET_ID);
      case LOCALNET_CHAIN_ID:
        return _SubnetId.fromString(LOCALNET_SUBNET_ID);
      case DEVNET_CHAIN_ID:
        return _SubnetId.fromString(DEVNET_SUBNET_ID);
      default:
        throw new Error("invalid chain id");
    }
  }
  // Create a new subnet ID with a specific chain ID
  withChainId(chainId) {
    return new _SubnetId(this.real.root, this.real.route, chainId, this.faux);
  }
  // Set the chain ID for this subnet ID
  setChainId(chainId) {
    this.explicitChainId = chainId;
  }
  // Check if this subnet ID is the root subnet
  isRoot() {
    return this.real.route.length === 0;
  }
  // Get the root ID for this subnet ID
  rootId() {
    return this.real.root;
  }
  // Get the string representation of this subnet ID (e.g. FVM-style, like `/r31337/t410...`)
  toString() {
    if (this.isRoot()) {
      return this.faux.length === 0 ? `/r${this.real.root}` : this.faux;
    }
    const route = this.real.route.join("/");
    return `/r${this.real.root}/${route}`;
  }
  // Get the chain ID for this subnet ID
  // See here for how this is derived as per EIP-2294:
  // https://github.com/consensus-shipyard/ipc/blob/13e5da5572b5c0de09f5481ef6c679efee0da14c/fendermint/vm/core/src/chainid.rs#L52
  chainId() {
    if (this.explicitChainId !== void 0) {
      return this.explicitChainId;
    }
    if (this.isRoot() && this.faux.length === 0) {
      return this.real.root;
    }
    const maxChainId = 4503599627370476n;
    const hash = (value) => fnv1a(value, { size: 64 }) % maxChainId;
    return Number(hash(this.toString()));
  }
  // Get the subnet actor address for this subnet ID
  subnetActorAddress(type = "evm") {
    if (this.isRoot()) {
      return void 0;
    }
    return type === "evm" ? this.evm.route[-1] : this.real.route[-1];
  }
  // Get the parent subnet ID for this subnet ID
  parent() {
    if (this.real.route.length === 0) {
      throw new Error("subnet has no parent");
    }
    const parentRoute = this.real.route.slice(0, -1);
    return new _SubnetId(this.real.root, parentRoute, void 0, "");
  }
};

export {
  SubnetId
};
