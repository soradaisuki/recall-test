"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  actorIdToMaskedEvmAddress: () => actorIdToMaskedEvmAddress,
  camelToSnake: () => camelToSnake,
  convertAbiMetadataToObject: () => convertAbiMetadataToObject,
  convertMetadataToAbiParams: () => convertMetadataToAbiParams,
  createFileHandler: () => createFileHandler,
  hexToBase64: () => hexToBase64,
  parseEventFromTransaction: () => parseEventFromTransaction,
  snakeToCamel: () => snakeToCamel
});
module.exports = __toCommonJS(utils_exports);
var import_viem = require("viem");
var import_viem2 = require("viem");
var import_address = require("@recallnet/fvm/address");
var import_utils = require("@recallnet/fvm/utils");
function bytesToBase64(bytes, safeUrl = true) {
  const binary = String.fromCodePoint(...bytes);
  let base64;
  if (typeof globalThis.btoa === "function") {
    base64 = globalThis.btoa(binary);
  } else if (typeof Buffer !== "undefined") {
    base64 = Buffer.from(binary, "binary").toString("base64");
  } else {
    throw new Error("Environment not supported for Base64 encoding");
  }
  return safeUrl ? base64.replace(/\+/g, "-").replace(/\//g, "_") : base64;
}
function hexToBase64(hex, safeUrl = true) {
  const bytes = (0, import_viem2.hexToBytes)(hex);
  return bytesToBase64(bytes, safeUrl);
}
function snakeToCamel(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),
      value
    ])
  );
}
function camelToSnake(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key.replace(/([A-Z])/g, "_$1").toLowerCase(),
      // Recursively transform nested objects
      value && typeof value === "object" && !Array.isArray(value) ? camelToSnake(value) : value
    ])
  );
}
var createFileHandler = () => ({
  async readFile(input) {
    if (typeof File !== "undefined" && input instanceof File) {
      const data2 = new Uint8Array(await input.arrayBuffer());
      return {
        data: data2,
        contentType: input.type,
        size: BigInt(input.size)
      };
    }
    if (typeof input === "string") {
      if (typeof window !== "undefined") {
        throw new Error("File paths are not supported in browser environment");
      }
      const fs = await import(
        /* webpackIgnore: true */
        "fs/promises"
      ).catch(
        () => null
      );
      if (!fs) {
        throw new Error("File system not available in this environment");
      }
      const data2 = await fs.readFile(input);
      const { fileTypeFromBuffer } = await import("file-type");
      const type = await fileTypeFromBuffer(data2);
      return {
        data: new Uint8Array(data2),
        contentType: type?.mime || "application/octet-stream",
        size: BigInt(data2.length)
      };
    }
    const data = input instanceof Uint8Array ? input : new Uint8Array(await input.arrayBuffer());
    return {
      data,
      contentType: "application/octet-stream",
      size: BigInt(data.length)
    };
  }
});
async function parseEventFromTransaction(client, abi, eventName, hash) {
  const receipt = await client.waitForTransactionReceipt({
    hash
  });
  const logs = (0, import_viem.parseEventLogs)({
    abi,
    logs: receipt.logs
  });
  const log = logs.find((log2) => log2.eventName === eventName);
  if (!log) {
    throw new Error(`Event ${eventName} not found`);
  }
  return log.args;
}
function convertMetadataToAbiParams(value) {
  return Object.entries(value).map(([key, value2]) => ({ key, value: value2 }));
}
function convertAbiMetadataToObject(metadata) {
  return metadata.reduce(
    (acc, { key, value }) => {
      acc[key] = value;
      return acc;
    },
    {}
  );
}
function actorIdToMaskedEvmAddress(actorId) {
  const actorIdBytes = new Uint8Array([
    0,
    ...import_utils.leb128.unsigned.encode(actorId)
  ]);
  return import_address.AddressId.fromBytes(actorIdBytes).toEthAddressHex();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  actorIdToMaskedEvmAddress,
  camelToSnake,
  convertAbiMetadataToObject,
  convertMetadataToAbiParams,
  createFileHandler,
  hexToBase64,
  parseEventFromTransaction,
  snakeToCamel
});
