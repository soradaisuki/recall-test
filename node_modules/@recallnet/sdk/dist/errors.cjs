"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/errors.ts
var errors_exports = {};
__export(errors_exports, {
  ActorNotFound: () => ActorNotFound,
  AddObjectError: () => AddObjectError,
  BucketNotFound: () => BucketNotFound,
  CreateBucketError: () => CreateBucketError,
  InsufficientFunds: () => InsufficientFunds,
  InvalidValue: () => InvalidValue,
  ObjectNotAvailable: () => ObjectNotAvailable,
  ObjectNotFound: () => ObjectNotFound,
  OutOfGasError: () => OutOfGasError,
  UnhandledBlobError: () => UnhandledBlobError,
  UnhandledBucketError: () => UnhandledBucketError,
  UnhandledCreditError: () => UnhandledCreditError,
  UnhandledGatewayError: () => UnhandledGatewayError,
  isActorNotFoundError: () => isActorNotFoundError
});
module.exports = __toCommonJS(errors_exports);
var import_address = require("@recallnet/fvm/address");
var BucketNotFound = class extends Error {
  constructor(bucket) {
    super(`Bucket not found: '${bucket}'`);
    this.name = "BucketNotFound";
  }
};
var OutOfGasError = class extends Error {
  constructor(message) {
    super(`Out of gas: ${message}`);
    this.name = "OutOfGas";
  }
};
var CreateBucketError = class extends Error {
  constructor(message) {
    super(`Failed to create bucket: ${message}`);
    this.name = "CreateBucketError";
  }
};
var AddObjectError = class extends Error {
  constructor(message) {
    super(`Failed to add object: ${message}`);
    this.name = "AddObjectError";
  }
};
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var ObjectNotAvailable = class extends Error {
  constructor(key, blobHash) {
    super(
      `Object not available: unrecoverable key '${key}' with blob hash '${blobHash}'`
    );
    this.name = "ObjectNotAvailable";
  }
};
var ObjectNotFound = class extends Error {
  constructor(bucket, key) {
    super(`Object not found: no key '${key}' in bucket '${bucket}'`);
    this.name = "ObjectNotFound";
  }
};
var UnhandledBucketError = class extends Error {
  constructor(message) {
    super(`Bucket error: ${message}`);
    this.name = "UnhandledBucketError";
  }
};
var UnhandledCreditError = class extends Error {
  constructor(message) {
    super(`Credit error: ${message}`);
    this.name = "UnhandledCreditError";
  }
};
var UnhandledBlobError = class extends Error {
  constructor(message) {
    super(`Blob error: ${message}`);
    this.name = "UnhandledBlobError";
  }
};
var UnhandledGatewayError = class extends Error {
  constructor(message) {
    super(`Gateway error: ${message}`);
    this.name = "UnhandledGatewayError";
  }
};
var InsufficientFunds = class extends Error {
  constructor(amount) {
    super(`Insufficient funds: balance less than amount '${amount}'`);
    this.name = "InsufficientFunds";
  }
};
function isActorNotFoundError(error) {
  const isActorNotFound = error.message.includes(
    "actor::resolve_address -- actor not found"
  );
  const addressMatch = error.message.match(/f410[a-z0-9]+/i);
  return {
    isActorNotFound,
    address: addressMatch ? import_address.FilEthAddress.fromString(addressMatch[0]).toEthAddressHex() : null
  };
}
var ActorNotFound = class extends Error {
  constructor(address) {
    super(
      `Actor not found (hint: ensure the address is registered: '${address}')`
    );
    this.name = "ActorNotFound";
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ActorNotFound,
  AddObjectError,
  BucketNotFound,
  CreateBucketError,
  InsufficientFunds,
  InvalidValue,
  ObjectNotAvailable,
  ObjectNotFound,
  OutOfGasError,
  UnhandledBlobError,
  UnhandledBucketError,
  UnhandledCreditError,
  UnhandledGatewayError,
  isActorNotFoundError
});
