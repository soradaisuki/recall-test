"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/ipc/index.ts
var ipc_exports = {};
__export(ipc_exports, {
  GatewayManager: () => GatewayManager,
  SubnetId: () => SubnetId
});
module.exports = __toCommonJS(ipc_exports);

// src/ipc/gateway.ts
var import_viem = require("viem");
var import_contracts = require("@recallnet/contracts");
var import_address2 = require("@recallnet/fvm/address");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var UnhandledGatewayError = class extends Error {
  constructor(message) {
    super(`Gateway error: ${message}`);
    this.name = "UnhandledGatewayError";
  }
};
var InsufficientFunds = class extends Error {
  constructor(amount) {
    super(`Insufficient funds: balance less than amount '${amount}'`);
    this.name = "InsufficientFunds";
  }
};

// src/ipc/gateway.ts
function addressToFvmAddressTyped(address) {
  const addr = import_address2.AddressDelegated.fromEthAddress(address);
  return { addrType: addr.getProtocol(), payload: (0, import_viem.toHex)(addr.getPayload()) };
}
function fundParamsToTyped(address, subnetId, amount) {
  const fvmAddress = addressToFvmAddressTyped(address);
  const subnet = {
    root: BigInt(subnetId.evm.root),
    route: subnetId.evm.route
  };
  return [subnet, fvmAddress, amount];
}
function releaseParamsToTyped(address) {
  const fvmAddress = addressToFvmAddressTyped(address);
  return [fvmAddress];
}
var GatewayManager = class {
  getContract(publicClient, walletClient, contractAddress) {
    const chainId = publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    return (0, import_viem.getContract)({
      abi: import_contracts.gatewayManagerFacetAbi,
      address: contractAddress,
      client: {
        public: publicClient,
        wallet: walletClient
      }
    });
  }
  // Fund gateway with tokens. Assumes the request is coming from the parent chain for a specific
  // child chain (identified by the subnet ID).
  async fundWithToken(publicClient, walletClient, contractAddress, forSubnet, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for funding gateway");
    }
    try {
      const recipientAddress = recipient || walletClient.account.address;
      const args = fundParamsToTyped(recipientAddress, forSubnet, amount);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.fundWithToken(args, {
        account: walletClient.account,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        if (error.message.includes("insufficient funds")) {
          throw new InsufficientFunds(amount);
        }
      }
      throw new UnhandledGatewayError(`Failed to fund gateway: ${error}`);
    }
  }
  // Release funds from gateway (child chain to parent chain)
  async release(publicClient, walletClient, contractAddress, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for releasing funds");
    }
    try {
      const address = recipient || walletClient.account.address;
      const args = releaseParamsToTyped(address);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.release(args, {
        account: walletClient.account,
        value: amount,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledGatewayError(`Failed to release funds: ${error}`);
    }
  }
};

// src/ipc/subnet.ts
var import_fnv1a = __toESM(require("@sindresorhus/fnv1a"), 1);
var import_address3 = require("@recallnet/fvm/address");
var import_network_constants = require("@recallnet/network-constants");
var SubnetId = class _SubnetId {
  faux;
  real;
  // Uses FVM addresses
  evm;
  // Uses EVM addresses
  explicitChainId;
  constructor(root, route, chainId, faux = "") {
    this.real = {
      root,
      route
    };
    const evmRoute = route.length > 0 ? route.map((a) => import_address3.FilEthAddress.fromString(a).toEthAddressHex()) : [];
    this.evm = {
      root,
      route: evmRoute
    };
    this.faux = faux;
    this.explicitChainId = chainId;
  }
  // Create a subnet ID from a string, like "/r31337/t410..."
  static fromString(subnetIdStr) {
    if (!subnetIdStr.toString().startsWith("/r")) {
      return new _SubnetId(0, [], void 0, subnetIdStr);
    }
    const [, rootRaw, routeRaw] = subnetIdStr.split("/");
    const root = Number(rootRaw?.slice(1));
    const route = routeRaw ? routeRaw.split("/") : [];
    let chainId;
    switch (subnetIdStr) {
      case import_network_constants.TESTNET_SUBNET_ID:
        chainId = import_network_constants.TESTNET_CHAIN_ID;
        break;
      case import_network_constants.LOCALNET_SUBNET_ID:
        chainId = import_network_constants.LOCALNET_CHAIN_ID;
        break;
      case import_network_constants.DEVNET_SUBNET_ID:
        chainId = import_network_constants.DEVNET_CHAIN_ID;
        break;
    }
    return new _SubnetId(root, route, chainId, subnetIdStr);
  }
  // Create a subnet ID from an official chain
  static fromChain(chain) {
    switch (chain.id) {
      case import_network_constants.TESTNET_CHAIN_ID:
        return _SubnetId.fromString(import_network_constants.TESTNET_SUBNET_ID);
      case import_network_constants.LOCALNET_CHAIN_ID:
        return _SubnetId.fromString(import_network_constants.LOCALNET_SUBNET_ID);
      case import_network_constants.DEVNET_CHAIN_ID:
        return _SubnetId.fromString(import_network_constants.DEVNET_SUBNET_ID);
      default:
        throw new Error("invalid chain id");
    }
  }
  // Create a new subnet ID with a specific chain ID
  withChainId(chainId) {
    return new _SubnetId(this.real.root, this.real.route, chainId, this.faux);
  }
  // Set the chain ID for this subnet ID
  setChainId(chainId) {
    this.explicitChainId = chainId;
  }
  // Check if this subnet ID is the root subnet
  isRoot() {
    return this.real.route.length === 0;
  }
  // Get the root ID for this subnet ID
  rootId() {
    return this.real.root;
  }
  // Get the string representation of this subnet ID (e.g. FVM-style, like `/r31337/t410...`)
  toString() {
    if (this.isRoot()) {
      return this.faux.length === 0 ? `/r${this.real.root}` : this.faux;
    }
    const route = this.real.route.join("/");
    return `/r${this.real.root}/${route}`;
  }
  // Get the chain ID for this subnet ID
  // See here for how this is derived as per EIP-2294:
  // https://github.com/consensus-shipyard/ipc/blob/13e5da5572b5c0de09f5481ef6c679efee0da14c/fendermint/vm/core/src/chainid.rs#L52
  chainId() {
    if (this.explicitChainId !== void 0) {
      return this.explicitChainId;
    }
    if (this.isRoot() && this.faux.length === 0) {
      return this.real.root;
    }
    const maxChainId = 4503599627370476n;
    const hash = (value) => (0, import_fnv1a.default)(value, { size: 64 }) % maxChainId;
    return Number(hash(this.toString()));
  }
  // Get the subnet actor address for this subnet ID
  subnetActorAddress(type = "evm") {
    if (this.isRoot()) {
      return void 0;
    }
    return type === "evm" ? this.evm.route[-1] : this.real.route[-1];
  }
  // Get the parent subnet ID for this subnet ID
  parent() {
    if (this.real.route.length === 0) {
      throw new Error("subnet has no parent");
    }
    const parentRoute = this.real.route.slice(0, -1);
    return new _SubnetId(this.real.root, parentRoute, void 0, "");
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  GatewayManager,
  SubnetId
});
