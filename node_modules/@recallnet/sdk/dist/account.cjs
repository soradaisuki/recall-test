"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/entities/account.ts
var account_exports = {};
__export(account_exports, {
  AccountManager: () => AccountManager
});
module.exports = __toCommonJS(account_exports);
var import_viem2 = require("viem");
var import_chains = require("@recallnet/chains");
var import_contracts2 = require("@recallnet/contracts");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var UnhandledGatewayError = class extends Error {
  constructor(message) {
    super(`Gateway error: ${message}`);
    this.name = "UnhandledGatewayError";
  }
};
var InsufficientFunds = class extends Error {
  constructor(amount) {
    super(`Insufficient funds: balance less than amount '${amount}'`);
    this.name = "InsufficientFunds";
  }
};

// src/ipc/gateway.ts
var import_viem = require("viem");
var import_contracts = require("@recallnet/contracts");
var import_address2 = require("@recallnet/fvm/address");
function addressToFvmAddressTyped(address) {
  const addr = import_address2.AddressDelegated.fromEthAddress(address);
  return { addrType: addr.getProtocol(), payload: (0, import_viem.toHex)(addr.getPayload()) };
}
function fundParamsToTyped(address, subnetId, amount) {
  const fvmAddress = addressToFvmAddressTyped(address);
  const subnet = {
    root: BigInt(subnetId.evm.root),
    route: subnetId.evm.route
  };
  return [subnet, fvmAddress, amount];
}
function releaseParamsToTyped(address) {
  const fvmAddress = addressToFvmAddressTyped(address);
  return [fvmAddress];
}
var GatewayManager = class {
  getContract(publicClient, walletClient, contractAddress) {
    const chainId = publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    return (0, import_viem.getContract)({
      abi: import_contracts.gatewayManagerFacetAbi,
      address: contractAddress,
      client: {
        public: publicClient,
        wallet: walletClient
      }
    });
  }
  // Fund gateway with tokens. Assumes the request is coming from the parent chain for a specific
  // child chain (identified by the subnet ID).
  async fundWithToken(publicClient, walletClient, contractAddress, forSubnet, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for funding gateway");
    }
    try {
      const recipientAddress = recipient || walletClient.account.address;
      const args = fundParamsToTyped(recipientAddress, forSubnet, amount);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.fundWithToken(args, {
        account: walletClient.account,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        if (error.message.includes("insufficient funds")) {
          throw new InsufficientFunds(amount);
        }
      }
      throw new UnhandledGatewayError(`Failed to fund gateway: ${error}`);
    }
  }
  // Release funds from gateway (child chain to parent chain)
  async release(publicClient, walletClient, contractAddress, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for releasing funds");
    }
    try {
      const address = recipient || walletClient.account.address;
      const args = releaseParamsToTyped(address);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.release(args, {
        account: walletClient.account,
        value: amount,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledGatewayError(`Failed to release funds: ${error}`);
    }
  }
};

// src/entities/account.ts
var AccountManager = class {
  client;
  gatewayManager;
  constructor(client) {
    this.client = client;
    this.gatewayManager = new GatewayManager();
  }
  // Get the gateway manager class and underlying contract
  // TODO: the logic for getting the gateway manager is a bit convoluted at the moment wrt
  // contract overrides.
  getGatewayManager() {
    return this.gatewayManager;
  }
  // Switch between parent and child subnet
  async switchSubnet(from, to) {
    return {
      change: async () => await this.client.switchChain(to),
      reset: async () => await this.client.switchChain(from)
    };
  }
  // Get the supply source contract
  getSupplySource(chain, contractAddress) {
    const chainId = chain.id;
    const deployedSupplySourceAddress = import_contracts2.recallErc20Address[chainId];
    const overrideConfig = this.client.contractOverrides.accountManager?.recallErc20;
    const overrideSupplySourceAddress = overrideConfig ? overrideConfig[chainId] : void 0;
    const override = contractAddress ?? overrideSupplySourceAddress ?? deployedSupplySourceAddress;
    if (!override) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    return (0, import_viem2.getContract)({
      abi: import_contracts2.recallErc20Abi,
      address: override,
      client: {
        public: this.client.publicClient,
        wallet: this.client.walletClient
      }
    });
  }
  // Get account balance
  async balance(address) {
    const addr = address || this.client.walletClient?.account?.address;
    if (!addr) {
      throw new InvalidValue(
        "Must provide an address or connect a wallet client"
      );
    }
    return {
      result: await this.client.publicClient.getBalance({ address: addr })
    };
  }
  // Get account info
  async info(address) {
    const addr = address || this.client.walletClient?.account?.address;
    if (!addr) {
      throw new InvalidValue(
        "Must provide an address or connect a wallet client"
      );
    }
    const balance = await this.balance(addr);
    const nonce = await this.client.publicClient.getTransactionCount({
      address: addr
    });
    const currentChain = this.client.publicClient.chain;
    const parentChain = (0, import_chains.getParentChain)(currentChain);
    if (!parentChain) {
      return { result: { address: addr, nonce, balance: balance.result } };
    }
    const { change, reset } = await this.switchSubnet(
      currentChain,
      parentChain
    );
    await change();
    const args = [addr];
    const parentBalance = await this.getSupplySource(
      this.client.publicClient.chain
    ).read.balanceOf(args);
    await reset();
    return {
      result: { address: addr, nonce, balance: balance.result, parentBalance }
    };
  }
  // Approve a spender to transfer funds from the account. Assumes the wallet client is on the
  // correct chain (i.e., should be connected to the parent chain, where the ERC20 exists).
  async approve(spender, amount, contractAddress) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for approving");
    }
    const args = [spender, amount];
    const gasPrice = await this.client.publicClient.getGasPrice();
    const supplySource = this.getSupplySource(
      this.client.walletClient.chain,
      contractAddress
    );
    const { request } = await supplySource.simulate.approve(
      args,
      {
        account: this.client.walletClient.account,
        gasPrice
      }
    );
    const hash = await this.client.walletClient.writeContract(request);
    const tx = await this.client.publicClient.waitForTransactionReceipt({
      hash
    });
    return { meta: { tx }, result: {} };
  }
  // Deposit funds from parent to child subnet. Assumes the wallet client is on the child chain,
  // and chain switching is handled automatically.
  async deposit(amount, recipient, contractAddress) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for approving");
    }
    const currentChain = this.client.publicClient.chain;
    const subnetId = this.client.getSubnetId();
    const parentChain = (0, import_chains.getParentChain)(currentChain);
    if (!parentChain) {
      throw new InvalidValue("No parent chain found");
    }
    const { change, reset } = await this.switchSubnet(
      currentChain,
      parentChain
    );
    await change();
    const chainId = this.client.walletClient?.chain.id;
    const deployedGatewayManagerFacetAddress = import_contracts2.gatewayManagerFacetConfig.address[chainId];
    const overrideConfig = this.client.contractOverrides.accountManager?.gatewayManager;
    const overrideGatewayAddress = overrideConfig ? overrideConfig[chainId] : void 0;
    const override = contractAddress ?? overrideGatewayAddress ?? deployedGatewayManagerFacetAddress;
    if (!override) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    await this.approve(override, amount);
    const result = await this.getGatewayManager().fundWithToken(
      this.client.publicClient,
      this.client.walletClient,
      override,
      subnetId,
      amount,
      recipient
    );
    await reset();
    return result;
  }
  // Withdraw funds from child subnet to parent
  async withdraw(amount, recipient, contractAddress) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for withdrawing");
    }
    const chainId = this.client.walletClient?.chain.id;
    const deployedGatewayManagerFacetAddress = import_contracts2.gatewayManagerFacetConfig.address[chainId];
    const overrideConfig = this.client.contractOverrides.accountManager?.gatewayManager;
    const overrideGatewayAddress = overrideConfig ? overrideConfig[chainId] : void 0;
    const override = contractAddress ?? overrideGatewayAddress ?? deployedGatewayManagerFacetAddress;
    if (!override) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    const result = await this.getGatewayManager().release(
      this.client.publicClient,
      this.client.walletClient,
      override,
      amount,
      recipient
    );
    return result;
  }
  // Transfer funds between accounts within the same subnet
  async transfer(recipient, amount) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for transfers");
    }
    const gasPrice = await this.client.publicClient.getGasPrice();
    const hash = await this.client.walletClient?.sendTransaction({
      account: this.client.walletClient.account,
      chain: this.client.walletClient.chain,
      to: recipient,
      value: amount,
      gasPrice
    });
    const tx = await this.client.publicClient.waitForTransactionReceipt({
      hash
    });
    return { meta: { tx }, result: {} };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountManager
});
