import {
  callObjectsApiAddObject,
  downloadBlob,
  getObjectsNodeInfo
} from "./chunk-4AFX2PSM.js";
import {
  convertAbiMetadataToObject,
  convertMetadataToAbiParams,
  createFileHandler,
  parseEventFromTransaction
} from "./chunk-DLYT7DCU.js";
import {
  ActorNotFound,
  AddObjectError,
  BucketNotFound,
  CreateBucketError,
  InvalidValue,
  ObjectNotFound,
  OutOfGasError,
  UnhandledBucketError,
  isActorNotFoundError
} from "./chunk-VDEK3UW2.js";

// src/entities/bucket.ts
import {
  ContractFunctionExecutionError,
  getContract
} from "viem";
import { getObjectApiUrl } from "@recallnet/chains";
import {
  bucketManagerAbi,
  bucketManagerAddress,
  iMachineFacadeAbi
} from "@recallnet/contracts";
import {
  MAX_OBJECT_SIZE,
  MAX_QUERY_LIMIT,
  MIN_TTL
} from "@recallnet/network-constants";
var BucketManager = class {
  fileHandler;
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedBucketManagerAddress = bucketManagerAddress[chainId];
    if (!deployedBucketManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = getContract({
      abi: bucketManagerAbi,
      address: contractAddress || deployedBucketManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
    this.fileHandler = createFileHandler();
  }
  getContract() {
    return this.contract;
  }
  // Create a bucket
  async create({
    owner,
    metadata
  } = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for creating a bucket");
    }
    try {
      const args = [
        owner ?? this.client.walletClient.account.address,
        metadata ? convertMetadataToAbiParams(metadata) : []
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.createBucket(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.contract.write.createBucket(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      const { machineAddress } = await parseEventFromTransaction(
        this.client.publicClient,
        iMachineFacadeAbi,
        "MachineInitialized",
        hash
      );
      return { meta: { tx }, result: { bucket: machineAddress } };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
        throw new CreateBucketError(error.message);
      }
      throw new UnhandledBucketError(`Failed to create bucket: ${error}`);
    }
  }
  // List buckets
  async list(owner, blockNumber) {
    let effectiveOwner;
    if (owner) {
      effectiveOwner = owner;
    } else if (this.client.walletClient?.account) {
      effectiveOwner = this.client.walletClient.account.address;
    } else {
      throw new Error("No owner provided or wallet client not initialized");
    }
    try {
      const listResult = await this.contract.read.listBuckets(
        [effectiveOwner],
        {
          blockNumber
        }
      );
      const result = listResult.map((bucket) => ({
        ...bucket,
        metadata: convertAbiMetadataToObject(bucket.metadata)
      }));
      return { result };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          return { result: [] };
        }
      }
      throw new UnhandledBucketError(`Failed to list buckets: ${error}`);
    }
  }
  // Add an object to a bucket inner
  async executeAdd(bucket, addParams) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    try {
      const args = [bucket, addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.addObject(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
        throw new AddObjectError(error.message);
      }
      throw new UnhandledBucketError(`${error}`);
    }
  }
  // Add an object to a bucket
  async add(bucket, key, file, options) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    const metadataRaw = options?.metadata ?? {};
    const { data, contentType, size } = await this.fileHandler.readFile(file);
    if (contentType) {
      metadataRaw["content-type"] = contentType;
    }
    const metadata = convertMetadataToAbiParams(metadataRaw);
    const objectApiUrl = getObjectApiUrl(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    if (size > MAX_OBJECT_SIZE) {
      throw new InvalidValue(
        `Object size must be less than ${MAX_OBJECT_SIZE} bytes`
      );
    }
    const ttl = options?.ttl ?? 0n;
    if (ttl !== 0n && ttl < MIN_TTL) {
      throw new InvalidValue(`TTL must be at least ${MIN_TTL} seconds`);
    }
    const { hash, metadataHash } = await callObjectsApiAddObject(
      objectApiUrl,
      data,
      size,
      contentType
    );
    const from = this.client.walletClient.account.address;
    const addParams = {
      source,
      key,
      blobHash: hash,
      recoveryHash: metadataHash,
      size,
      ttl,
      metadata,
      overwrite: options?.overwrite ?? false,
      from
    };
    return await this.executeAdd(bucket, addParams);
  }
  // Delete an object from a bucket
  async delete(bucket, key) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    try {
      const from = this.client.walletClient.account.address;
      const args = [bucket, key, from];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.deleteObject(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        if (error.message.includes("object not found")) {
          throw new ObjectNotFound(bucket, key);
        }
        throw new BucketNotFound(bucket);
      }
      throw new UnhandledBucketError(`Failed to delete object: ${error}`);
    }
  }
  // Get an object from a bucket, without downloading it
  async getObjectValue(bucket, key, blockNumber) {
    try {
      const args = [bucket, key];
      const getResult = await this.contract.read.getObject(args, {
        blockNumber
      });
      if (!getResult.blobHash) {
        throw new ObjectNotFound(bucket, key);
      }
      const result = {
        blobHash: getResult.blobHash,
        recoveryHash: getResult.recoveryHash,
        size: getResult.size,
        expiry: getResult.expiry,
        metadata: convertAbiMetadataToObject(getResult.metadata)
      };
      return { result };
    } catch (error) {
      if (error instanceof ObjectNotFound) {
        throw error;
      } else if (error instanceof ContractFunctionExecutionError) {
        throw new BucketNotFound(bucket);
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
  // Download an object from a bucket, returning a Uint8Array
  async get(bucket, key, options) {
    try {
      const objectApiUrl = getObjectApiUrl(this.client.publicClient.chain);
      const stream = await downloadBlob(
        objectApiUrl,
        bucket,
        key,
        options?.range,
        options?.blockNumber
      );
      const chunks = [];
      const reader = stream.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }
      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue || error instanceof ObjectNotFound || error instanceof BucketNotFound) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to download object: ${error}`);
    }
  }
  // Get a readable stream of an object from a bucket
  async getStream(bucket, key, range, blockNumber) {
    try {
      const objectApiUrl = getObjectApiUrl(this.client.publicClient.chain);
      const result = await downloadBlob(
        objectApiUrl,
        bucket,
        key,
        range,
        blockNumber
      );
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue || error instanceof ObjectNotFound || error instanceof BucketNotFound) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to download object: ${error}`);
    }
  }
  // Query objects in a bucket
  async query(bucket, options) {
    const requestedLimit = options?.limit ?? MAX_QUERY_LIMIT;
    if (requestedLimit <= MAX_QUERY_LIMIT) {
      return this.executeQuery(bucket, options);
    }
    try {
      const allObjects = [];
      let currentKey = options?.startKey;
      while (true) {
        const remainingLimit = requestedLimit - allObjects.length;
        const batchLimit = Math.min(MAX_QUERY_LIMIT, remainingLimit);
        const batchResult = await this.executeQuery(bucket, {
          ...options,
          startKey: currentKey,
          limit: batchLimit
        });
        allObjects.push(...batchResult.result.objects);
        if (!batchResult.result.nextKey || allObjects.length >= requestedLimit) {
          return {
            result: {
              objects: allObjects,
              commonPrefixes: batchResult.result.commonPrefixes,
              nextKey: batchResult.result.nextKey
            }
          };
        }
        currentKey = batchResult.result.nextKey;
      }
    } catch (error) {
      if (error instanceof BucketNotFound || error instanceof OutOfGasError || error instanceof UnhandledBucketError) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
  // Helper method for single query execution
  async executeQuery(bucket, options) {
    try {
      const args = [
        bucket,
        options?.prefix ?? "",
        options?.delimiter ?? "/",
        options?.startKey ?? "",
        BigInt(options?.limit ?? MAX_QUERY_LIMIT)
      ];
      const { objects, commonPrefixes, nextKey } = await this.contract.read.queryObjects(args, {
        blockNumber: options?.blockNumber
      });
      const result = {
        objects: objects.map(({ key, state }) => ({
          key,
          state: {
            blobHash: state.blobHash,
            size: state.size,
            expiry: state.expiry,
            metadata: convertAbiMetadataToObject(state.metadata)
          }
        })),
        commonPrefixes,
        nextKey
      };
      return { result };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        if (error.message.includes("contract reverted")) {
          const isOutOfGasError = error.message.includes("wasm `unreachable` instruction executed") || error.message.includes("out of gas");
          if (isOutOfGasError) {
            throw new OutOfGasError(error.message);
          }
          throw new BucketNotFound(bucket);
        }
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
};

export {
  BucketManager
};
