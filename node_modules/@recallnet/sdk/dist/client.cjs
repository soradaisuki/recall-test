"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/client.ts
var client_exports = {};
__export(client_exports, {
  RecallClient: () => RecallClient,
  createPublicClientForChain: () => createPublicClientForChain,
  walletClientFromPrivateKey: () => walletClientFromPrivateKey
});
module.exports = __toCommonJS(client_exports);
var import_viem8 = require("viem");
var import_accounts = require("viem/accounts");
var import_window = require("viem/window");
var import_chains4 = require("@recallnet/chains");

// src/entities/account.ts
var import_viem2 = require("viem");
var import_chains = require("@recallnet/chains");
var import_contracts2 = require("@recallnet/contracts");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var BucketNotFound = class extends Error {
  constructor(bucket) {
    super(`Bucket not found: '${bucket}'`);
    this.name = "BucketNotFound";
  }
};
var OutOfGasError = class extends Error {
  constructor(message) {
    super(`Out of gas: ${message}`);
    this.name = "OutOfGas";
  }
};
var CreateBucketError = class extends Error {
  constructor(message) {
    super(`Failed to create bucket: ${message}`);
    this.name = "CreateBucketError";
  }
};
var AddObjectError = class extends Error {
  constructor(message) {
    super(`Failed to add object: ${message}`);
    this.name = "AddObjectError";
  }
};
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var ObjectNotAvailable = class extends Error {
  constructor(key, blobHash) {
    super(
      `Object not available: unrecoverable key '${key}' with blob hash '${blobHash}'`
    );
    this.name = "ObjectNotAvailable";
  }
};
var ObjectNotFound = class extends Error {
  constructor(bucket, key) {
    super(`Object not found: no key '${key}' in bucket '${bucket}'`);
    this.name = "ObjectNotFound";
  }
};
var UnhandledBucketError = class extends Error {
  constructor(message) {
    super(`Bucket error: ${message}`);
    this.name = "UnhandledBucketError";
  }
};
var UnhandledCreditError = class extends Error {
  constructor(message) {
    super(`Credit error: ${message}`);
    this.name = "UnhandledCreditError";
  }
};
var UnhandledBlobError = class extends Error {
  constructor(message) {
    super(`Blob error: ${message}`);
    this.name = "UnhandledBlobError";
  }
};
var UnhandledGatewayError = class extends Error {
  constructor(message) {
    super(`Gateway error: ${message}`);
    this.name = "UnhandledGatewayError";
  }
};
var InsufficientFunds = class extends Error {
  constructor(amount) {
    super(`Insufficient funds: balance less than amount '${amount}'`);
    this.name = "InsufficientFunds";
  }
};
function isActorNotFoundError(error) {
  const isActorNotFound = error.message.includes(
    "actor::resolve_address -- actor not found"
  );
  const addressMatch = error.message.match(/f410[a-z0-9]+/i);
  return {
    isActorNotFound,
    address: addressMatch ? import_address.FilEthAddress.fromString(addressMatch[0]).toEthAddressHex() : null
  };
}
var ActorNotFound = class extends Error {
  constructor(address) {
    super(
      `Actor not found (hint: ensure the address is registered: '${address}')`
    );
    this.name = "ActorNotFound";
  }
};

// src/ipc/gateway.ts
var import_viem = require("viem");
var import_contracts = require("@recallnet/contracts");
var import_address2 = require("@recallnet/fvm/address");
function addressToFvmAddressTyped(address) {
  const addr = import_address2.AddressDelegated.fromEthAddress(address);
  return { addrType: addr.getProtocol(), payload: (0, import_viem.toHex)(addr.getPayload()) };
}
function fundParamsToTyped(address, subnetId, amount) {
  const fvmAddress = addressToFvmAddressTyped(address);
  const subnet = {
    root: BigInt(subnetId.evm.root),
    route: subnetId.evm.route
  };
  return [subnet, fvmAddress, amount];
}
function releaseParamsToTyped(address) {
  const fvmAddress = addressToFvmAddressTyped(address);
  return [fvmAddress];
}
var GatewayManager = class {
  getContract(publicClient, walletClient, contractAddress) {
    const chainId = publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    return (0, import_viem.getContract)({
      abi: import_contracts.gatewayManagerFacetAbi,
      address: contractAddress,
      client: {
        public: publicClient,
        wallet: walletClient
      }
    });
  }
  // Fund gateway with tokens. Assumes the request is coming from the parent chain for a specific
  // child chain (identified by the subnet ID).
  async fundWithToken(publicClient, walletClient, contractAddress, forSubnet, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for funding gateway");
    }
    try {
      const recipientAddress = recipient || walletClient.account.address;
      const args = fundParamsToTyped(recipientAddress, forSubnet, amount);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.fundWithToken(args, {
        account: walletClient.account,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        if (error.message.includes("insufficient funds")) {
          throw new InsufficientFunds(amount);
        }
      }
      throw new UnhandledGatewayError(`Failed to fund gateway: ${error}`);
    }
  }
  // Release funds from gateway (child chain to parent chain)
  async release(publicClient, walletClient, contractAddress, amount, recipient) {
    if (!walletClient.account) {
      throw new Error("Wallet client is not initialized for releasing funds");
    }
    try {
      const address = recipient || walletClient.account.address;
      const args = releaseParamsToTyped(address);
      const gasPrice = await publicClient.getGasPrice();
      const { request } = await this.getContract(
        publicClient,
        walletClient,
        contractAddress
      ).simulate.release(args, {
        account: walletClient.account,
        value: amount,
        gasPrice
      });
      const hash = await walletClient.writeContract(request);
      const tx = await publicClient.waitForTransactionReceipt({ hash });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledGatewayError(`Failed to release funds: ${error}`);
    }
  }
};

// src/entities/account.ts
var AccountManager = class {
  client;
  gatewayManager;
  constructor(client) {
    this.client = client;
    this.gatewayManager = new GatewayManager();
  }
  // Get the gateway manager class and underlying contract
  // TODO: the logic for getting the gateway manager is a bit convoluted at the moment wrt
  // contract overrides.
  getGatewayManager() {
    return this.gatewayManager;
  }
  // Switch between parent and child subnet
  async switchSubnet(from, to) {
    return {
      change: async () => await this.client.switchChain(to),
      reset: async () => await this.client.switchChain(from)
    };
  }
  // Get the supply source contract
  getSupplySource(chain, contractAddress) {
    const chainId = chain.id;
    const deployedSupplySourceAddress = import_contracts2.recallErc20Address[chainId];
    const overrideConfig = this.client.contractOverrides.accountManager?.recallErc20;
    const overrideSupplySourceAddress = overrideConfig ? overrideConfig[chainId] : void 0;
    const override = contractAddress ?? overrideSupplySourceAddress ?? deployedSupplySourceAddress;
    if (!override) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    return (0, import_viem2.getContract)({
      abi: import_contracts2.recallErc20Abi,
      address: override,
      client: {
        public: this.client.publicClient,
        wallet: this.client.walletClient
      }
    });
  }
  // Get account balance
  async balance(address) {
    const addr = address || this.client.walletClient?.account?.address;
    if (!addr) {
      throw new InvalidValue(
        "Must provide an address or connect a wallet client"
      );
    }
    return {
      result: await this.client.publicClient.getBalance({ address: addr })
    };
  }
  // Get account info
  async info(address) {
    const addr = address || this.client.walletClient?.account?.address;
    if (!addr) {
      throw new InvalidValue(
        "Must provide an address or connect a wallet client"
      );
    }
    const balance = await this.balance(addr);
    const nonce = await this.client.publicClient.getTransactionCount({
      address: addr
    });
    const currentChain = this.client.publicClient.chain;
    const parentChain = (0, import_chains.getParentChain)(currentChain);
    if (!parentChain) {
      return { result: { address: addr, nonce, balance: balance.result } };
    }
    const { change, reset } = await this.switchSubnet(
      currentChain,
      parentChain
    );
    await change();
    const args = [addr];
    const parentBalance = await this.getSupplySource(
      this.client.publicClient.chain
    ).read.balanceOf(args);
    await reset();
    return {
      result: { address: addr, nonce, balance: balance.result, parentBalance }
    };
  }
  // Approve a spender to transfer funds from the account. Assumes the wallet client is on the
  // correct chain (i.e., should be connected to the parent chain, where the ERC20 exists).
  async approve(spender, amount, contractAddress) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for approving");
    }
    const args = [spender, amount];
    const gasPrice = await this.client.publicClient.getGasPrice();
    const supplySource = this.getSupplySource(
      this.client.walletClient.chain,
      contractAddress
    );
    const { request } = await supplySource.simulate.approve(
      args,
      {
        account: this.client.walletClient.account,
        gasPrice
      }
    );
    const hash = await this.client.walletClient.writeContract(request);
    const tx = await this.client.publicClient.waitForTransactionReceipt({
      hash
    });
    return { meta: { tx }, result: {} };
  }
  // Deposit funds from parent to child subnet. Assumes the wallet client is on the child chain,
  // and chain switching is handled automatically.
  async deposit(amount, recipient, contractAddress) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for approving");
    }
    const currentChain = this.client.publicClient.chain;
    const subnetId = this.client.getSubnetId();
    const parentChain = (0, import_chains.getParentChain)(currentChain);
    if (!parentChain) {
      throw new InvalidValue("No parent chain found");
    }
    const { change, reset } = await this.switchSubnet(
      currentChain,
      parentChain
    );
    await change();
    const chainId = this.client.walletClient?.chain.id;
    const deployedGatewayManagerFacetAddress = import_contracts2.gatewayManagerFacetConfig.address[chainId];
    const overrideConfig = this.client.contractOverrides.accountManager?.gatewayManager;
    const overrideGatewayAddress = overrideConfig ? overrideConfig[chainId] : void 0;
    const override = contractAddress ?? overrideGatewayAddress ?? deployedGatewayManagerFacetAddress;
    if (!override) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    await this.approve(override, amount);
    const result = await this.getGatewayManager().fundWithToken(
      this.client.publicClient,
      this.client.walletClient,
      override,
      subnetId,
      amount,
      recipient
    );
    await reset();
    return result;
  }
  // Withdraw funds from child subnet to parent
  async withdraw(amount, recipient, contractAddress) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for withdrawing");
    }
    const chainId = this.client.walletClient?.chain.id;
    const deployedGatewayManagerFacetAddress = import_contracts2.gatewayManagerFacetConfig.address[chainId];
    const overrideConfig = this.client.contractOverrides.accountManager?.gatewayManager;
    const overrideGatewayAddress = overrideConfig ? overrideConfig[chainId] : void 0;
    const override = contractAddress ?? overrideGatewayAddress ?? deployedGatewayManagerFacetAddress;
    if (!override) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    const result = await this.getGatewayManager().release(
      this.client.publicClient,
      this.client.walletClient,
      override,
      amount,
      recipient
    );
    return result;
  }
  // Transfer funds between accounts within the same subnet
  async transfer(recipient, amount) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for transfers");
    }
    const gasPrice = await this.client.publicClient.getGasPrice();
    const hash = await this.client.walletClient?.sendTransaction({
      account: this.client.walletClient.account,
      chain: this.client.walletClient.chain,
      to: recipient,
      value: amount,
      gasPrice
    });
    const tx = await this.client.publicClient.waitForTransactionReceipt({
      hash
    });
    return { meta: { tx }, result: {} };
  }
};

// src/entities/blob.ts
var import_viem5 = require("viem");
var import_chains2 = require("@recallnet/chains");
var import_contracts3 = require("@recallnet/contracts");
var import_network_constants = require("@recallnet/network-constants");

// src/provider.ts
var import_address4 = require("@recallnet/fvm/address");

// src/utils.ts
var import_viem3 = require("viem");
var import_viem4 = require("viem");
var import_address3 = require("@recallnet/fvm/address");
var import_utils = require("@recallnet/fvm/utils");
function snakeToCamel(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),
      value
    ])
  );
}
var createFileHandler = () => ({
  async readFile(input) {
    if (typeof File !== "undefined" && input instanceof File) {
      const data2 = new Uint8Array(await input.arrayBuffer());
      return {
        data: data2,
        contentType: input.type,
        size: BigInt(input.size)
      };
    }
    if (typeof input === "string") {
      if (typeof window !== "undefined") {
        throw new Error("File paths are not supported in browser environment");
      }
      const fs = await import(
        /* webpackIgnore: true */
        "fs/promises"
      ).catch(
        () => null
      );
      if (!fs) {
        throw new Error("File system not available in this environment");
      }
      const data2 = await fs.readFile(input);
      const { fileTypeFromBuffer } = await import("file-type");
      const type = await fileTypeFromBuffer(data2);
      return {
        data: new Uint8Array(data2),
        contentType: type?.mime || "application/octet-stream",
        size: BigInt(data2.length)
      };
    }
    const data = input instanceof Uint8Array ? input : new Uint8Array(await input.arrayBuffer());
    return {
      data,
      contentType: "application/octet-stream",
      size: BigInt(data.length)
    };
  }
});
async function parseEventFromTransaction(client, abi, eventName, hash) {
  const receipt = await client.waitForTransactionReceipt({
    hash
  });
  const logs = (0, import_viem3.parseEventLogs)({
    abi,
    logs: receipt.logs
  });
  const log = logs.find((log2) => log2.eventName === eventName);
  if (!log) {
    throw new Error(`Event ${eventName} not found`);
  }
  return log.args;
}
function convertMetadataToAbiParams(value) {
  return Object.entries(value).map(([key, value2]) => ({ key, value: value2 }));
}
function convertAbiMetadataToObject(metadata) {
  return metadata.reduce(
    (acc, { key, value }) => {
      acc[key] = value;
      return acc;
    },
    {}
  );
}

// src/provider.ts
function createObjectsFormData({
  data,
  size,
  contentType
}) {
  const formData = new FormData();
  formData.append("size", size.toString());
  formData.append(
    "data",
    new File([data], "blob", {
      type: contentType ?? "application/octet-stream"
    })
  );
  return formData;
}
async function getObjectsNodeInfo(objectsProviderUrl) {
  const response = await fetch(`${objectsProviderUrl}/v1/node`);
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function callObjectsApiAddObject(objectsProviderUrl, data, size, contentType) {
  const formData = createObjectsFormData({
    data,
    size,
    contentType
  });
  const response = await fetch(`${objectsProviderUrl}/v1/objects`, {
    method: "POST",
    body: formData
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function downloadBlob(objectsProviderUrl, bucket, key, range, blockNumber) {
  const headers = {};
  if (range) {
    headers.Range = `bytes=${range.start ?? ""}-${range.end ?? ""}`;
  }
  const bucketIdAddress = import_address4.AddressId.fromEthAddress(bucket);
  const url = new URL(
    `${objectsProviderUrl}/v1/objects/${bucketIdAddress}/${key}`
  );
  if (blockNumber !== void 0) {
    url.searchParams.set("height", blockNumber.toString());
  }
  const response = await fetch(url, {
    headers
  });
  if (!response.ok) {
    const error = await response.json();
    if (error.message.includes("actor does not exist")) {
      throw new BucketNotFound(bucket);
    }
    if (error.message.includes("is not available")) {
      const blobHash = error.message.match(/object\s+(.*)\s+is not available/)?.[1] ?? "";
      throw new ObjectNotAvailable(key, blobHash);
    }
    if (error.message.includes("invalid range header")) {
      throw new InvalidValue(
        `Invalid range: ${range?.start ?? ""}-${range?.end ?? ""}`
      );
    }
    throw new UnhandledBucketError(
      `Failed to download object: ${error.message}`
    );
  }
  if (!response.body) {
    throw new UnhandledBucketError("Failed to download object: no body");
  }
  return response.body;
}

// src/entities/blob.ts
var BlobManager = class {
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedBlobManagerAddress = import_contracts3.blobManagerAddress[chainId];
    if (!deployedBlobManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = (0, import_viem5.getContract)({
      abi: import_contracts3.blobManagerAbi,
      address: contractAddress || deployedBlobManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
  }
  getContract() {
    return this.contract;
  }
  // Add blob inner
  async addBlobInner(addParams) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding blobs");
    }
    try {
      const args = [addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.addBlob(
        args,
        {
          account: this.client.walletClient.account,
          gasPrice
        }
      );
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem5.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to add blob: ${error}`);
    }
  }
  // Add blob
  // TODO: this assumes the blob already exists on the network; there's no way to upload raw blobs
  // to the objects API (it requires a bucket and a key)
  async addBlob(blobHash, subscriptionId, size, options = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding blobs");
    }
    const ttl = options?.ttl ?? 0n;
    if (ttl !== 0n && ttl < import_network_constants.MIN_TTL) {
      throw new InvalidValue(`TTL must be at least ${import_network_constants.MIN_TTL} seconds`);
    }
    const objectApiUrl = (0, import_chains2.getObjectApiUrl)(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    const from = this.client.walletClient.account.address;
    const addParams = {
      sponsor: options.sponsor ?? import_viem5.zeroAddress,
      source,
      blobHash,
      metadataHash: "",
      subscriptionId,
      size,
      ttl,
      from
    };
    return this.addBlobInner(addParams);
  }
  // Delete blob
  async deleteBlob(blobHash, subscriptionId, subscriber) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for deleting blobs");
    }
    try {
      const from = this.client.walletClient.account.address;
      const args = [
        subscriber || import_viem5.zeroAddress,
        blobHash,
        subscriptionId,
        from
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.deleteBlob(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem5.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to delete blob: ${error}`);
    }
  }
  // Get blob info
  // TODO: there's no way to download raw blobs from the objects API (it requires a bucket and a key)
  async getBlob(blobHash, blockNumber) {
    try {
      const args = [blobHash];
      const result = await this.contract.read.getBlob(args, { blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get blob info: ${error}`);
    }
  }
  // Get blob status
  async getBlobStatus(subscriber, blobHash, subscriptionId, blockNumber) {
    try {
      const args = [
        subscriber,
        blobHash,
        subscriptionId
      ];
      const result = await this.contract.read.getBlobStatus(args, {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof import_viem5.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to get blob status: ${error}`);
    }
  }
  // Overwrite blob inner
  async overwriteBlobInner(oldHash, addParams) {
    try {
      if (!this.client.walletClient?.account) {
        throw new Error(
          "Wallet client is not initialized for overwriting blobs"
        );
      }
      const params = [oldHash, addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.overwriteBlob(params, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to overwrite blob: ${error}`);
    }
  }
  // Overwrite blob
  async overwriteBlob(oldHash, newHash, subscriptionId, size, options = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for overwriting blobs");
    }
    const objectApiUrl = (0, import_chains2.getObjectApiUrl)(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    const from = this.client.walletClient.account.address;
    const params = {
      sponsor: options.sponsor ?? import_viem5.zeroAddress,
      source,
      blobHash: newHash,
      metadataHash: "",
      subscriptionId,
      size,
      ttl: options.ttl ?? 0n,
      from
    };
    return this.overwriteBlobInner(oldHash, params);
  }
  // Get added blobs
  async getAddedBlobs(size, blockNumber) {
    try {
      const result = await this.contract.read.getAddedBlobs([size], {
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get added blobs: ${error}`);
    }
  }
  // Get pending blobs
  async getPendingBlobs(size, blockNumber) {
    try {
      const result = await this.contract.read.getPendingBlobs([size], {
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending blobs count: ${error}`
      );
    }
  }
  // Get pending blobs count
  async getPendingBlobsCount(blockNumber) {
    try {
      const result = await this.contract.read.getPendingBlobsCount({
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending blobs count: ${error}`
      );
    }
  }
  // Get pending bytes count
  async getPendingBytesCount(blockNumber) {
    try {
      const result = await this.contract.read.getPendingBytesCount({
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending bytes count: ${error}`
      );
    }
  }
  // Get storage stats
  async getStorageStats(blockNumber) {
    try {
      const result = await this.contract.read.getStorageStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get storage stats: ${error}`);
    }
  }
  // Get storage usage
  async getStorageUsage(address, blockNumber) {
    const addressArg = address || this.client.walletClient?.account?.address;
    if (!addressArg) {
      throw new Error("Address is required for getting storage usage");
    }
    try {
      const result = await this.contract.read.getStorageUsage([addressArg], {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof import_viem5.ContractFunctionExecutionError) {
        const { isActorNotFound, address: address2 } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address2);
        }
      }
      throw new UnhandledBlobError(`Failed to get storage usage: ${error}`);
    }
  }
  // Get subnet stats
  async getSubnetStats(blockNumber) {
    try {
      const result = await this.contract.read.getSubnetStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get subnet stats: ${error}`);
    }
  }
};

// src/entities/bucket.ts
var import_viem6 = require("viem");
var import_chains3 = require("@recallnet/chains");
var import_contracts4 = require("@recallnet/contracts");
var import_network_constants2 = require("@recallnet/network-constants");
var BucketManager = class {
  fileHandler;
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedBucketManagerAddress = import_contracts4.bucketManagerAddress[chainId];
    if (!deployedBucketManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = (0, import_viem6.getContract)({
      abi: import_contracts4.bucketManagerAbi,
      address: contractAddress || deployedBucketManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
    this.fileHandler = createFileHandler();
  }
  getContract() {
    return this.contract;
  }
  // Create a bucket
  async create({
    owner,
    metadata
  } = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for creating a bucket");
    }
    try {
      const args = [
        owner ?? this.client.walletClient.account.address,
        metadata ? convertMetadataToAbiParams(metadata) : []
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.createBucket(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.contract.write.createBucket(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      const { machineAddress } = await parseEventFromTransaction(
        this.client.publicClient,
        import_contracts4.iMachineFacadeAbi,
        "MachineInitialized",
        hash
      );
      return { meta: { tx }, result: { bucket: machineAddress } };
    } catch (error) {
      if (error instanceof import_viem6.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
        throw new CreateBucketError(error.message);
      }
      throw new UnhandledBucketError(`Failed to create bucket: ${error}`);
    }
  }
  // List buckets
  async list(owner, blockNumber) {
    let effectiveOwner;
    if (owner) {
      effectiveOwner = owner;
    } else if (this.client.walletClient?.account) {
      effectiveOwner = this.client.walletClient.account.address;
    } else {
      throw new Error("No owner provided or wallet client not initialized");
    }
    try {
      const listResult = await this.contract.read.listBuckets(
        [effectiveOwner],
        {
          blockNumber
        }
      );
      const result = listResult.map((bucket) => ({
        ...bucket,
        metadata: convertAbiMetadataToObject(bucket.metadata)
      }));
      return { result };
    } catch (error) {
      if (error instanceof import_viem6.ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          return { result: [] };
        }
      }
      throw new UnhandledBucketError(`Failed to list buckets: ${error}`);
    }
  }
  // Add an object to a bucket inner
  async executeAdd(bucket, addParams) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    try {
      const args = [bucket, addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.addObject(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem6.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
        throw new AddObjectError(error.message);
      }
      throw new UnhandledBucketError(`${error}`);
    }
  }
  // Add an object to a bucket
  async add(bucket, key, file, options) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    const metadataRaw = options?.metadata ?? {};
    const { data, contentType, size } = await this.fileHandler.readFile(file);
    if (contentType) {
      metadataRaw["content-type"] = contentType;
    }
    const metadata = convertMetadataToAbiParams(metadataRaw);
    const objectApiUrl = (0, import_chains3.getObjectApiUrl)(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    if (size > import_network_constants2.MAX_OBJECT_SIZE) {
      throw new InvalidValue(
        `Object size must be less than ${import_network_constants2.MAX_OBJECT_SIZE} bytes`
      );
    }
    const ttl = options?.ttl ?? 0n;
    if (ttl !== 0n && ttl < import_network_constants2.MIN_TTL) {
      throw new InvalidValue(`TTL must be at least ${import_network_constants2.MIN_TTL} seconds`);
    }
    const { hash, metadataHash } = await callObjectsApiAddObject(
      objectApiUrl,
      data,
      size,
      contentType
    );
    const from = this.client.walletClient.account.address;
    const addParams = {
      source,
      key,
      blobHash: hash,
      recoveryHash: metadataHash,
      size,
      ttl,
      metadata,
      overwrite: options?.overwrite ?? false,
      from
    };
    return await this.executeAdd(bucket, addParams);
  }
  // Delete an object from a bucket
  async delete(bucket, key) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    try {
      const from = this.client.walletClient.account.address;
      const args = [bucket, key, from];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.deleteObject(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem6.ContractFunctionExecutionError) {
        if (error.message.includes("object not found")) {
          throw new ObjectNotFound(bucket, key);
        }
        throw new BucketNotFound(bucket);
      }
      throw new UnhandledBucketError(`Failed to delete object: ${error}`);
    }
  }
  // Get an object from a bucket, without downloading it
  async getObjectValue(bucket, key, blockNumber) {
    try {
      const args = [bucket, key];
      const getResult = await this.contract.read.getObject(args, {
        blockNumber
      });
      if (!getResult.blobHash) {
        throw new ObjectNotFound(bucket, key);
      }
      const result = {
        blobHash: getResult.blobHash,
        recoveryHash: getResult.recoveryHash,
        size: getResult.size,
        expiry: getResult.expiry,
        metadata: convertAbiMetadataToObject(getResult.metadata)
      };
      return { result };
    } catch (error) {
      if (error instanceof ObjectNotFound) {
        throw error;
      } else if (error instanceof import_viem6.ContractFunctionExecutionError) {
        throw new BucketNotFound(bucket);
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
  // Download an object from a bucket, returning a Uint8Array
  async get(bucket, key, options) {
    try {
      const objectApiUrl = (0, import_chains3.getObjectApiUrl)(this.client.publicClient.chain);
      const stream = await downloadBlob(
        objectApiUrl,
        bucket,
        key,
        options?.range,
        options?.blockNumber
      );
      const chunks = [];
      const reader = stream.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }
      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue || error instanceof ObjectNotFound || error instanceof BucketNotFound) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to download object: ${error}`);
    }
  }
  // Get a readable stream of an object from a bucket
  async getStream(bucket, key, range, blockNumber) {
    try {
      const objectApiUrl = (0, import_chains3.getObjectApiUrl)(this.client.publicClient.chain);
      const result = await downloadBlob(
        objectApiUrl,
        bucket,
        key,
        range,
        blockNumber
      );
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue || error instanceof ObjectNotFound || error instanceof BucketNotFound) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to download object: ${error}`);
    }
  }
  // Query objects in a bucket
  async query(bucket, options) {
    const requestedLimit = options?.limit ?? import_network_constants2.MAX_QUERY_LIMIT;
    if (requestedLimit <= import_network_constants2.MAX_QUERY_LIMIT) {
      return this.executeQuery(bucket, options);
    }
    try {
      const allObjects = [];
      let currentKey = options?.startKey;
      while (true) {
        const remainingLimit = requestedLimit - allObjects.length;
        const batchLimit = Math.min(import_network_constants2.MAX_QUERY_LIMIT, remainingLimit);
        const batchResult = await this.executeQuery(bucket, {
          ...options,
          startKey: currentKey,
          limit: batchLimit
        });
        allObjects.push(...batchResult.result.objects);
        if (!batchResult.result.nextKey || allObjects.length >= requestedLimit) {
          return {
            result: {
              objects: allObjects,
              commonPrefixes: batchResult.result.commonPrefixes,
              nextKey: batchResult.result.nextKey
            }
          };
        }
        currentKey = batchResult.result.nextKey;
      }
    } catch (error) {
      if (error instanceof BucketNotFound || error instanceof OutOfGasError || error instanceof UnhandledBucketError) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
  // Helper method for single query execution
  async executeQuery(bucket, options) {
    try {
      const args = [
        bucket,
        options?.prefix ?? "",
        options?.delimiter ?? "/",
        options?.startKey ?? "",
        BigInt(options?.limit ?? import_network_constants2.MAX_QUERY_LIMIT)
      ];
      const { objects, commonPrefixes, nextKey } = await this.contract.read.queryObjects(args, {
        blockNumber: options?.blockNumber
      });
      const result = {
        objects: objects.map(({ key, state }) => ({
          key,
          state: {
            blobHash: state.blobHash,
            size: state.size,
            expiry: state.expiry,
            metadata: convertAbiMetadataToObject(state.metadata)
          }
        })),
        commonPrefixes,
        nextKey
      };
      return { result };
    } catch (error) {
      if (error instanceof import_viem6.ContractFunctionExecutionError) {
        if (error.message.includes("contract reverted")) {
          const isOutOfGasError = error.message.includes("wasm `unreachable` instruction executed") || error.message.includes("out of gas");
          if (isOutOfGasError) {
            throw new OutOfGasError(error.message);
          }
          throw new BucketNotFound(bucket);
        }
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
};

// src/entities/credit.ts
var import_viem7 = require("viem");
var import_contracts5 = require("@recallnet/contracts");
var CreditManager = class {
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedCreditManagerAddress = import_contracts5.creditManagerAddress[chainId];
    if (!deployedCreditManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = (0, import_viem7.getContract)({
      abi: import_contracts5.creditManagerAbi,
      address: contractAddress || deployedCreditManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
  }
  getContract() {
    return this.contract;
  }
  // Approve credit spending
  // TODO: maybe make the input params an object for easier optional params
  async approve(to, caller = [], creditLimit = 0n, gasFeeLimit = 0n, ttl = 0n, from) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for approving credits");
    }
    const fromAddress = from || this.client.walletClient.account.address;
    try {
      const args = [
        fromAddress,
        to,
        caller,
        creditLimit,
        gasFeeLimit,
        ttl
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.approveCredit(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem7.ContractFunctionExecutionError) {
        if (error.message.includes("does not match origin or caller")) {
          throw new InvalidValue(
            `'from' address '${fromAddress}' does not match origin or caller '${this.client.walletClient.account.address}'`
          );
        }
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to approve credits: ${error}`);
    }
  }
  // Buy credits
  async buy(amount, to) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for buying credits");
    }
    const balance = await this.client.publicClient.getBalance({
      address: this.client.walletClient.account.address
    });
    if (balance < amount) {
      throw new InsufficientFunds(amount);
    }
    try {
      const toAddress = to || this.client.walletClient.account.address;
      const args = [toAddress];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.buyCredit(args, {
        value: amount,
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.contract.write.buyCredit(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem7.ContractFunctionExecutionError) {
        if (error.message.includes("insufficient funds")) {
          throw new InsufficientFunds(amount);
        }
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to buy credits: ${error}`);
    }
  }
  // Revoke credit approval
  async revoke(to, requiredCaller = to, from) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for revoking credits");
    }
    const fromAddress = from || this.client.walletClient.account.address;
    try {
      const args = [
        fromAddress,
        to,
        requiredCaller
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.revokeCredit(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem7.ContractFunctionExecutionError) {
        if (error.message.includes("does not match origin or caller")) {
          throw new InvalidValue(
            `'from' address '${fromAddress}' does not match origin or caller '${this.client.walletClient.account.address}'`
          );
        }
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to revoke credits: ${error}`);
    }
  }
  // Set account sponsor
  async setAccountSponsor(sponsor, from) {
    if (!this.client.walletClient?.account) {
      throw new Error(
        "Wallet client is not initialized for setting account sponsor"
      );
    }
    const fromAddress = from || this.client.walletClient.account.address;
    try {
      const args = [fromAddress, sponsor];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.setAccountSponsor(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem7.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to set account sponsor: ${error}`);
    }
  }
  // Get account details including approvals
  async getAccount(address, blockNumber) {
    try {
      const forAddress = address || this.client.walletClient?.account?.address;
      if (!forAddress)
        throw new InvalidValue(
          "Must provide an address or connect a wallet client"
        );
      const args = [forAddress];
      const result = await this.contract.read.getAccount(args, { blockNumber });
      return { result };
    } catch (error) {
      if (error instanceof import_viem7.ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          const emptyAccount = {
            capacityUsed: 0n,
            creditFree: 0n,
            creditCommitted: 0n,
            creditSponsor: "0x0000000000000000000000000000000000000000",
            lastDebitEpoch: 0n,
            approvalsTo: [],
            approvalsFrom: [],
            maxTtl: 0n,
            gasAllowance: 0n
          };
          return { result: emptyAccount };
        }
      }
      throw new UnhandledCreditError(`Failed to get account details: ${error}`);
    }
  }
  // Get credit approvals
  async getCreditApprovals(forAddress, {
    filterFrom,
    filterTo,
    blockNumber
  } = {}) {
    let {
      result: { approvalsTo, approvalsFrom }
    } = await this.getAccount(forAddress, blockNumber);
    approvalsTo = filterTo ? approvalsTo.filter((approval) => approval.addr === filterTo) : approvalsTo;
    approvalsFrom = filterFrom ? approvalsFrom.filter((approval) => approval.addr === filterFrom) : approvalsFrom;
    return { result: { approvalsTo, approvalsFrom } };
  }
  // Get credit balance
  async getCreditBalance(address, blockNumber) {
    try {
      const forAddress = address || this.client.walletClient?.account?.address;
      if (!forAddress)
        throw new InvalidValue(
          "Must provide an address or connect a wallet client"
        );
      const args = [forAddress];
      const result = await this.contract.read.getCreditBalance(args, {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue) {
        throw error;
      }
      if (error instanceof import_viem7.ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          const emptyBalance = {
            creditFree: 0n,
            creditCommitted: 0n,
            creditSponsor: import_viem7.zeroAddress,
            lastDebitEpoch: 0n,
            approvalsTo: [],
            approvalsFrom: [],
            gasAllowance: 0n
          };
          return { result: emptyBalance };
        }
      }
      throw new UnhandledCreditError(`Failed to get credit balance: ${error}`);
    }
  }
  // Get credit stats
  async getCreditStats(blockNumber) {
    try {
      const result = await this.contract.read.getCreditStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledCreditError(`Failed to get credit stats: ${error}`);
    }
  }
};

// src/ipc/subnet.ts
var import_fnv1a = __toESM(require("@sindresorhus/fnv1a"), 1);
var import_address5 = require("@recallnet/fvm/address");
var import_network_constants3 = require("@recallnet/network-constants");
var SubnetId = class _SubnetId {
  faux;
  real;
  // Uses FVM addresses
  evm;
  // Uses EVM addresses
  explicitChainId;
  constructor(root, route, chainId, faux = "") {
    this.real = {
      root,
      route
    };
    const evmRoute = route.length > 0 ? route.map((a) => import_address5.FilEthAddress.fromString(a).toEthAddressHex()) : [];
    this.evm = {
      root,
      route: evmRoute
    };
    this.faux = faux;
    this.explicitChainId = chainId;
  }
  // Create a subnet ID from a string, like "/r31337/t410..."
  static fromString(subnetIdStr) {
    if (!subnetIdStr.toString().startsWith("/r")) {
      return new _SubnetId(0, [], void 0, subnetIdStr);
    }
    const [, rootRaw, routeRaw] = subnetIdStr.split("/");
    const root = Number(rootRaw?.slice(1));
    const route = routeRaw ? routeRaw.split("/") : [];
    let chainId;
    switch (subnetIdStr) {
      case import_network_constants3.TESTNET_SUBNET_ID:
        chainId = import_network_constants3.TESTNET_CHAIN_ID;
        break;
      case import_network_constants3.LOCALNET_SUBNET_ID:
        chainId = import_network_constants3.LOCALNET_CHAIN_ID;
        break;
      case import_network_constants3.DEVNET_SUBNET_ID:
        chainId = import_network_constants3.DEVNET_CHAIN_ID;
        break;
    }
    return new _SubnetId(root, route, chainId, subnetIdStr);
  }
  // Create a subnet ID from an official chain
  static fromChain(chain) {
    switch (chain.id) {
      case import_network_constants3.TESTNET_CHAIN_ID:
        return _SubnetId.fromString(import_network_constants3.TESTNET_SUBNET_ID);
      case import_network_constants3.LOCALNET_CHAIN_ID:
        return _SubnetId.fromString(import_network_constants3.LOCALNET_SUBNET_ID);
      case import_network_constants3.DEVNET_CHAIN_ID:
        return _SubnetId.fromString(import_network_constants3.DEVNET_SUBNET_ID);
      default:
        throw new Error("invalid chain id");
    }
  }
  // Create a new subnet ID with a specific chain ID
  withChainId(chainId) {
    return new _SubnetId(this.real.root, this.real.route, chainId, this.faux);
  }
  // Set the chain ID for this subnet ID
  setChainId(chainId) {
    this.explicitChainId = chainId;
  }
  // Check if this subnet ID is the root subnet
  isRoot() {
    return this.real.route.length === 0;
  }
  // Get the root ID for this subnet ID
  rootId() {
    return this.real.root;
  }
  // Get the string representation of this subnet ID (e.g. FVM-style, like `/r31337/t410...`)
  toString() {
    if (this.isRoot()) {
      return this.faux.length === 0 ? `/r${this.real.root}` : this.faux;
    }
    const route = this.real.route.join("/");
    return `/r${this.real.root}/${route}`;
  }
  // Get the chain ID for this subnet ID
  // See here for how this is derived as per EIP-2294:
  // https://github.com/consensus-shipyard/ipc/blob/13e5da5572b5c0de09f5481ef6c679efee0da14c/fendermint/vm/core/src/chainid.rs#L52
  chainId() {
    if (this.explicitChainId !== void 0) {
      return this.explicitChainId;
    }
    if (this.isRoot() && this.faux.length === 0) {
      return this.real.root;
    }
    const maxChainId = 4503599627370476n;
    const hash = (value) => (0, import_fnv1a.default)(value, { size: 64 }) % maxChainId;
    return Number(hash(this.toString()));
  }
  // Get the subnet actor address for this subnet ID
  subnetActorAddress(type = "evm") {
    if (this.isRoot()) {
      return void 0;
    }
    return type === "evm" ? this.evm.route[-1] : this.real.route[-1];
  }
  // Get the parent subnet ID for this subnet ID
  parent() {
    if (this.real.route.length === 0) {
      throw new Error("subnet has no parent");
    }
    const parentRoute = this.real.route.slice(0, -1);
    return new _SubnetId(this.real.root, parentRoute, void 0, "");
  }
};

// src/client.ts
var createPublicClientForChain = (chain = import_chains4.testnet) => (0, import_viem8.createPublicClient)({
  chain,
  transport: (0, import_viem8.http)()
});
var walletClientFromPrivateKey = (privateKey, chain = import_chains4.testnet) => {
  const hexPrivateKey = (0, import_viem8.isHex)(privateKey) ? privateKey : `0x${privateKey}`;
  return (0, import_viem8.createWalletClient)({
    account: (0, import_accounts.privateKeyToAccount)(hexPrivateKey),
    chain,
    transport: (0, import_viem8.http)()
  });
};
var RecallClient = class _RecallClient {
  publicClient;
  walletClient;
  contractOverrides;
  subnetId;
  // TODO: this logic probably needs to be refactored to properly handle conflicts
  constructor(config = {}) {
    if (config.walletClient) this.walletClient = config.walletClient;
    if (config.publicClient) {
      this.publicClient = config.publicClient;
    } else {
      this.publicClient = config.walletClient ? _RecallClient.fromChain(config.walletClient.chain).publicClient : _RecallClient.fromChain().publicClient;
    }
    const chain = this.publicClient.chain;
    if (!chain) throw new Error("missing chain in provided client");
    this.subnetId = SubnetId.fromChain(chain);
    this.contractOverrides = config.contractOverrides ?? {};
  }
  // Creates a RecallClient with read & write capabilities from a private key
  static fromPrivateKey(privateKey, chain = import_chains4.testnet, contractOverrides) {
    const walletClient = walletClientFromPrivateKey(privateKey, chain);
    const publicClient = createPublicClientForChain(chain);
    return new _RecallClient({
      publicClient,
      walletClient,
      contractOverrides
    });
  }
  // Creates a public RecallClient from a chain
  static fromChain(chain = import_chains4.testnet, contractOverrides) {
    return new _RecallClient({
      publicClient: (0, import_viem8.createPublicClient)({ chain, transport: (0, import_viem8.http)() }),
      contractOverrides
    });
  }
  // Creates a public RecallClient from a chain name
  static fromChainName(chainName = "testnet") {
    return new _RecallClient({
      publicClient: (0, import_viem8.createPublicClient)({
        chain: (0, import_chains4.getChain)(chainName),
        transport: (0, import_viem8.http)()
      })
    });
  }
  // Switches the chain for the client (e.g., from/to a parent and child subnet chain)
  async switchChain(chain) {
    this.publicClient = createPublicClientForChain(chain);
    if (!this.walletClient) return;
    const isBrowserWallet = this.walletClient.transport.type === "custom";
    if (isBrowserWallet) {
      await this.walletClient.switchChain({ id: chain.id });
    } else {
      this.walletClient = (0, import_viem8.createWalletClient)({
        chain,
        account: this.walletClient.account,
        transport: (0, import_viem8.http)()
      });
    }
  }
  // Returns the subnet ID for the client
  getSubnetId() {
    return this.subnetId;
  }
  // Creates an AccountManager for the client
  accountManager() {
    return new AccountManager(this);
  }
  // Creates a BlobManager for the client
  blobManager(contractAddress) {
    const override = contractAddress ?? this.contractOverrides.blobManager?.[this.publicClient.chain.id];
    return new BlobManager(this, override);
  }
  // Creates a BucketManager for the client
  bucketManager(contractAddress) {
    const override = contractAddress ?? this.contractOverrides.bucketManager?.[this.publicClient.chain.id];
    return new BucketManager(this, override);
  }
  // Creates a CreditManager for the client
  creditManager(contractAddress) {
    const override = contractAddress ?? this.contractOverrides.creditManager?.[this.publicClient.chain.id];
    return new CreditManager(this, override);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RecallClient,
  createPublicClientForChain,
  walletClientFromPrivateKey
});
