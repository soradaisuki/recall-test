import {
  getObjectsNodeInfo
} from "./chunk-4AFX2PSM.js";
import {
  ActorNotFound,
  InvalidValue,
  UnhandledBlobError,
  isActorNotFoundError
} from "./chunk-VDEK3UW2.js";

// src/entities/blob.ts
import {
  ContractFunctionExecutionError,
  getContract,
  zeroAddress
} from "viem";
import { getObjectApiUrl } from "@recallnet/chains";
import { blobManagerAbi, blobManagerAddress } from "@recallnet/contracts";
import { MIN_TTL } from "@recallnet/network-constants";
var BlobManager = class {
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedBlobManagerAddress = blobManagerAddress[chainId];
    if (!deployedBlobManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = getContract({
      abi: blobManagerAbi,
      address: contractAddress || deployedBlobManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
  }
  getContract() {
    return this.contract;
  }
  // Add blob inner
  async addBlobInner(addParams) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding blobs");
    }
    try {
      const args = [addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.addBlob(
        args,
        {
          account: this.client.walletClient.account,
          gasPrice
        }
      );
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to add blob: ${error}`);
    }
  }
  // Add blob
  // TODO: this assumes the blob already exists on the network; there's no way to upload raw blobs
  // to the objects API (it requires a bucket and a key)
  async addBlob(blobHash, subscriptionId, size, options = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding blobs");
    }
    const ttl = options?.ttl ?? 0n;
    if (ttl !== 0n && ttl < MIN_TTL) {
      throw new InvalidValue(`TTL must be at least ${MIN_TTL} seconds`);
    }
    const objectApiUrl = getObjectApiUrl(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    const from = this.client.walletClient.account.address;
    const addParams = {
      sponsor: options.sponsor ?? zeroAddress,
      source,
      blobHash,
      metadataHash: "",
      subscriptionId,
      size,
      ttl,
      from
    };
    return this.addBlobInner(addParams);
  }
  // Delete blob
  async deleteBlob(blobHash, subscriptionId, subscriber) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for deleting blobs");
    }
    try {
      const from = this.client.walletClient.account.address;
      const args = [
        subscriber || zeroAddress,
        blobHash,
        subscriptionId,
        from
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.deleteBlob(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to delete blob: ${error}`);
    }
  }
  // Get blob info
  // TODO: there's no way to download raw blobs from the objects API (it requires a bucket and a key)
  async getBlob(blobHash, blockNumber) {
    try {
      const args = [blobHash];
      const result = await this.contract.read.getBlob(args, { blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get blob info: ${error}`);
    }
  }
  // Get blob status
  async getBlobStatus(subscriber, blobHash, subscriptionId, blockNumber) {
    try {
      const args = [
        subscriber,
        blobHash,
        subscriptionId
      ];
      const result = await this.contract.read.getBlobStatus(args, {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledBlobError(`Failed to get blob status: ${error}`);
    }
  }
  // Overwrite blob inner
  async overwriteBlobInner(oldHash, addParams) {
    try {
      if (!this.client.walletClient?.account) {
        throw new Error(
          "Wallet client is not initialized for overwriting blobs"
        );
      }
      const params = [oldHash, addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.overwriteBlob(params, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to overwrite blob: ${error}`);
    }
  }
  // Overwrite blob
  async overwriteBlob(oldHash, newHash, subscriptionId, size, options = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for overwriting blobs");
    }
    const objectApiUrl = getObjectApiUrl(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    const from = this.client.walletClient.account.address;
    const params = {
      sponsor: options.sponsor ?? zeroAddress,
      source,
      blobHash: newHash,
      metadataHash: "",
      subscriptionId,
      size,
      ttl: options.ttl ?? 0n,
      from
    };
    return this.overwriteBlobInner(oldHash, params);
  }
  // Get added blobs
  async getAddedBlobs(size, blockNumber) {
    try {
      const result = await this.contract.read.getAddedBlobs([size], {
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get added blobs: ${error}`);
    }
  }
  // Get pending blobs
  async getPendingBlobs(size, blockNumber) {
    try {
      const result = await this.contract.read.getPendingBlobs([size], {
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending blobs count: ${error}`
      );
    }
  }
  // Get pending blobs count
  async getPendingBlobsCount(blockNumber) {
    try {
      const result = await this.contract.read.getPendingBlobsCount({
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending blobs count: ${error}`
      );
    }
  }
  // Get pending bytes count
  async getPendingBytesCount(blockNumber) {
    try {
      const result = await this.contract.read.getPendingBytesCount({
        blockNumber
      });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(
        `Failed to get pending bytes count: ${error}`
      );
    }
  }
  // Get storage stats
  async getStorageStats(blockNumber) {
    try {
      const result = await this.contract.read.getStorageStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get storage stats: ${error}`);
    }
  }
  // Get storage usage
  async getStorageUsage(address, blockNumber) {
    const addressArg = address || this.client.walletClient?.account?.address;
    if (!addressArg) {
      throw new Error("Address is required for getting storage usage");
    }
    try {
      const result = await this.contract.read.getStorageUsage([addressArg], {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError) {
        const { isActorNotFound, address: address2 } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address2);
        }
      }
      throw new UnhandledBlobError(`Failed to get storage usage: ${error}`);
    }
  }
  // Get subnet stats
  async getSubnetStats(blockNumber) {
    try {
      const result = await this.contract.read.getSubnetStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledBlobError(`Failed to get subnet stats: ${error}`);
    }
  }
};

export {
  BlobManager
};
