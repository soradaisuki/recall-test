"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/entities/bucket.ts
var bucket_exports = {};
__export(bucket_exports, {
  BucketManager: () => BucketManager
});
module.exports = __toCommonJS(bucket_exports);
var import_viem3 = require("viem");
var import_chains = require("@recallnet/chains");
var import_contracts = require("@recallnet/contracts");
var import_network_constants = require("@recallnet/network-constants");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var BucketNotFound = class extends Error {
  constructor(bucket) {
    super(`Bucket not found: '${bucket}'`);
    this.name = "BucketNotFound";
  }
};
var OutOfGasError = class extends Error {
  constructor(message) {
    super(`Out of gas: ${message}`);
    this.name = "OutOfGas";
  }
};
var CreateBucketError = class extends Error {
  constructor(message) {
    super(`Failed to create bucket: ${message}`);
    this.name = "CreateBucketError";
  }
};
var AddObjectError = class extends Error {
  constructor(message) {
    super(`Failed to add object: ${message}`);
    this.name = "AddObjectError";
  }
};
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var ObjectNotAvailable = class extends Error {
  constructor(key, blobHash) {
    super(
      `Object not available: unrecoverable key '${key}' with blob hash '${blobHash}'`
    );
    this.name = "ObjectNotAvailable";
  }
};
var ObjectNotFound = class extends Error {
  constructor(bucket, key) {
    super(`Object not found: no key '${key}' in bucket '${bucket}'`);
    this.name = "ObjectNotFound";
  }
};
var UnhandledBucketError = class extends Error {
  constructor(message) {
    super(`Bucket error: ${message}`);
    this.name = "UnhandledBucketError";
  }
};
function isActorNotFoundError(error) {
  const isActorNotFound = error.message.includes(
    "actor::resolve_address -- actor not found"
  );
  const addressMatch = error.message.match(/f410[a-z0-9]+/i);
  return {
    isActorNotFound,
    address: addressMatch ? import_address.FilEthAddress.fromString(addressMatch[0]).toEthAddressHex() : null
  };
}
var ActorNotFound = class extends Error {
  constructor(address) {
    super(
      `Actor not found (hint: ensure the address is registered: '${address}')`
    );
    this.name = "ActorNotFound";
  }
};

// src/provider.ts
var import_address3 = require("@recallnet/fvm/address");

// src/utils.ts
var import_viem = require("viem");
var import_viem2 = require("viem");
var import_address2 = require("@recallnet/fvm/address");
var import_utils = require("@recallnet/fvm/utils");
function snakeToCamel(obj) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => [
      key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),
      value
    ])
  );
}
var createFileHandler = () => ({
  async readFile(input) {
    if (typeof File !== "undefined" && input instanceof File) {
      const data2 = new Uint8Array(await input.arrayBuffer());
      return {
        data: data2,
        contentType: input.type,
        size: BigInt(input.size)
      };
    }
    if (typeof input === "string") {
      if (typeof window !== "undefined") {
        throw new Error("File paths are not supported in browser environment");
      }
      const fs = await import(
        /* webpackIgnore: true */
        "fs/promises"
      ).catch(
        () => null
      );
      if (!fs) {
        throw new Error("File system not available in this environment");
      }
      const data2 = await fs.readFile(input);
      const { fileTypeFromBuffer } = await import("file-type");
      const type = await fileTypeFromBuffer(data2);
      return {
        data: new Uint8Array(data2),
        contentType: type?.mime || "application/octet-stream",
        size: BigInt(data2.length)
      };
    }
    const data = input instanceof Uint8Array ? input : new Uint8Array(await input.arrayBuffer());
    return {
      data,
      contentType: "application/octet-stream",
      size: BigInt(data.length)
    };
  }
});
async function parseEventFromTransaction(client, abi, eventName, hash) {
  const receipt = await client.waitForTransactionReceipt({
    hash
  });
  const logs = (0, import_viem.parseEventLogs)({
    abi,
    logs: receipt.logs
  });
  const log = logs.find((log2) => log2.eventName === eventName);
  if (!log) {
    throw new Error(`Event ${eventName} not found`);
  }
  return log.args;
}
function convertMetadataToAbiParams(value) {
  return Object.entries(value).map(([key, value2]) => ({ key, value: value2 }));
}
function convertAbiMetadataToObject(metadata) {
  return metadata.reduce(
    (acc, { key, value }) => {
      acc[key] = value;
      return acc;
    },
    {}
  );
}

// src/provider.ts
function createObjectsFormData({
  data,
  size,
  contentType
}) {
  const formData = new FormData();
  formData.append("size", size.toString());
  formData.append(
    "data",
    new File([data], "blob", {
      type: contentType ?? "application/octet-stream"
    })
  );
  return formData;
}
async function getObjectsNodeInfo(objectsProviderUrl) {
  const response = await fetch(`${objectsProviderUrl}/v1/node`);
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function callObjectsApiAddObject(objectsProviderUrl, data, size, contentType) {
  const formData = createObjectsFormData({
    data,
    size,
    contentType
  });
  const response = await fetch(`${objectsProviderUrl}/v1/objects`, {
    method: "POST",
    body: formData
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(`Objects API error: ${error.message}`);
  }
  const json = await response.json();
  return snakeToCamel(json);
}
async function downloadBlob(objectsProviderUrl, bucket, key, range, blockNumber) {
  const headers = {};
  if (range) {
    headers.Range = `bytes=${range.start ?? ""}-${range.end ?? ""}`;
  }
  const bucketIdAddress = import_address3.AddressId.fromEthAddress(bucket);
  const url = new URL(
    `${objectsProviderUrl}/v1/objects/${bucketIdAddress}/${key}`
  );
  if (blockNumber !== void 0) {
    url.searchParams.set("height", blockNumber.toString());
  }
  const response = await fetch(url, {
    headers
  });
  if (!response.ok) {
    const error = await response.json();
    if (error.message.includes("actor does not exist")) {
      throw new BucketNotFound(bucket);
    }
    if (error.message.includes("is not available")) {
      const blobHash = error.message.match(/object\s+(.*)\s+is not available/)?.[1] ?? "";
      throw new ObjectNotAvailable(key, blobHash);
    }
    if (error.message.includes("invalid range header")) {
      throw new InvalidValue(
        `Invalid range: ${range?.start ?? ""}-${range?.end ?? ""}`
      );
    }
    throw new UnhandledBucketError(
      `Failed to download object: ${error.message}`
    );
  }
  if (!response.body) {
    throw new UnhandledBucketError("Failed to download object: no body");
  }
  return response.body;
}

// src/entities/bucket.ts
var BucketManager = class {
  fileHandler;
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedBucketManagerAddress = import_contracts.bucketManagerAddress[chainId];
    if (!deployedBucketManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = (0, import_viem3.getContract)({
      abi: import_contracts.bucketManagerAbi,
      address: contractAddress || deployedBucketManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
    this.fileHandler = createFileHandler();
  }
  getContract() {
    return this.contract;
  }
  // Create a bucket
  async create({
    owner,
    metadata
  } = {}) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for creating a bucket");
    }
    try {
      const args = [
        owner ?? this.client.walletClient.account.address,
        metadata ? convertMetadataToAbiParams(metadata) : []
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.createBucket(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.contract.write.createBucket(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      const { machineAddress } = await parseEventFromTransaction(
        this.client.publicClient,
        import_contracts.iMachineFacadeAbi,
        "MachineInitialized",
        hash
      );
      return { meta: { tx }, result: { bucket: machineAddress } };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
        throw new CreateBucketError(error.message);
      }
      throw new UnhandledBucketError(`Failed to create bucket: ${error}`);
    }
  }
  // List buckets
  async list(owner, blockNumber) {
    let effectiveOwner;
    if (owner) {
      effectiveOwner = owner;
    } else if (this.client.walletClient?.account) {
      effectiveOwner = this.client.walletClient.account.address;
    } else {
      throw new Error("No owner provided or wallet client not initialized");
    }
    try {
      const listResult = await this.contract.read.listBuckets(
        [effectiveOwner],
        {
          blockNumber
        }
      );
      const result = listResult.map((bucket) => ({
        ...bucket,
        metadata: convertAbiMetadataToObject(bucket.metadata)
      }));
      return { result };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          return { result: [] };
        }
      }
      throw new UnhandledBucketError(`Failed to list buckets: ${error}`);
    }
  }
  // Add an object to a bucket inner
  async executeAdd(bucket, addParams) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    try {
      const args = [bucket, addParams];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.addObject(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
        throw new AddObjectError(error.message);
      }
      throw new UnhandledBucketError(`${error}`);
    }
  }
  // Add an object to a bucket
  async add(bucket, key, file, options) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    const metadataRaw = options?.metadata ?? {};
    const { data, contentType, size } = await this.fileHandler.readFile(file);
    if (contentType) {
      metadataRaw["content-type"] = contentType;
    }
    const metadata = convertMetadataToAbiParams(metadataRaw);
    const objectApiUrl = (0, import_chains.getObjectApiUrl)(this.client.walletClient.chain);
    const { nodeId: source } = await getObjectsNodeInfo(objectApiUrl);
    if (size > import_network_constants.MAX_OBJECT_SIZE) {
      throw new InvalidValue(
        `Object size must be less than ${import_network_constants.MAX_OBJECT_SIZE} bytes`
      );
    }
    const ttl = options?.ttl ?? 0n;
    if (ttl !== 0n && ttl < import_network_constants.MIN_TTL) {
      throw new InvalidValue(`TTL must be at least ${import_network_constants.MIN_TTL} seconds`);
    }
    const { hash, metadataHash } = await callObjectsApiAddObject(
      objectApiUrl,
      data,
      size,
      contentType
    );
    const from = this.client.walletClient.account.address;
    const addParams = {
      source,
      key,
      blobHash: hash,
      recoveryHash: metadataHash,
      size,
      ttl,
      metadata,
      overwrite: options?.overwrite ?? false,
      from
    };
    return await this.executeAdd(bucket, addParams);
  }
  // Delete an object from a bucket
  async delete(bucket, key) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for adding an object");
    }
    try {
      const from = this.client.walletClient.account.address;
      const args = [bucket, key, from];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.deleteObject(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        if (error.message.includes("object not found")) {
          throw new ObjectNotFound(bucket, key);
        }
        throw new BucketNotFound(bucket);
      }
      throw new UnhandledBucketError(`Failed to delete object: ${error}`);
    }
  }
  // Get an object from a bucket, without downloading it
  async getObjectValue(bucket, key, blockNumber) {
    try {
      const args = [bucket, key];
      const getResult = await this.contract.read.getObject(args, {
        blockNumber
      });
      if (!getResult.blobHash) {
        throw new ObjectNotFound(bucket, key);
      }
      const result = {
        blobHash: getResult.blobHash,
        recoveryHash: getResult.recoveryHash,
        size: getResult.size,
        expiry: getResult.expiry,
        metadata: convertAbiMetadataToObject(getResult.metadata)
      };
      return { result };
    } catch (error) {
      if (error instanceof ObjectNotFound) {
        throw error;
      } else if (error instanceof import_viem3.ContractFunctionExecutionError) {
        throw new BucketNotFound(bucket);
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
  // Download an object from a bucket, returning a Uint8Array
  async get(bucket, key, options) {
    try {
      const objectApiUrl = (0, import_chains.getObjectApiUrl)(this.client.publicClient.chain);
      const stream = await downloadBlob(
        objectApiUrl,
        bucket,
        key,
        options?.range,
        options?.blockNumber
      );
      const chunks = [];
      const reader = stream.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }
      const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue || error instanceof ObjectNotFound || error instanceof BucketNotFound) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to download object: ${error}`);
    }
  }
  // Get a readable stream of an object from a bucket
  async getStream(bucket, key, range, blockNumber) {
    try {
      const objectApiUrl = (0, import_chains.getObjectApiUrl)(this.client.publicClient.chain);
      const result = await downloadBlob(
        objectApiUrl,
        bucket,
        key,
        range,
        blockNumber
      );
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue || error instanceof ObjectNotFound || error instanceof BucketNotFound) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to download object: ${error}`);
    }
  }
  // Query objects in a bucket
  async query(bucket, options) {
    const requestedLimit = options?.limit ?? import_network_constants.MAX_QUERY_LIMIT;
    if (requestedLimit <= import_network_constants.MAX_QUERY_LIMIT) {
      return this.executeQuery(bucket, options);
    }
    try {
      const allObjects = [];
      let currentKey = options?.startKey;
      while (true) {
        const remainingLimit = requestedLimit - allObjects.length;
        const batchLimit = Math.min(import_network_constants.MAX_QUERY_LIMIT, remainingLimit);
        const batchResult = await this.executeQuery(bucket, {
          ...options,
          startKey: currentKey,
          limit: batchLimit
        });
        allObjects.push(...batchResult.result.objects);
        if (!batchResult.result.nextKey || allObjects.length >= requestedLimit) {
          return {
            result: {
              objects: allObjects,
              commonPrefixes: batchResult.result.commonPrefixes,
              nextKey: batchResult.result.nextKey
            }
          };
        }
        currentKey = batchResult.result.nextKey;
      }
    } catch (error) {
      if (error instanceof BucketNotFound || error instanceof OutOfGasError || error instanceof UnhandledBucketError) {
        throw error;
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
  // Helper method for single query execution
  async executeQuery(bucket, options) {
    try {
      const args = [
        bucket,
        options?.prefix ?? "",
        options?.delimiter ?? "/",
        options?.startKey ?? "",
        BigInt(options?.limit ?? import_network_constants.MAX_QUERY_LIMIT)
      ];
      const { objects, commonPrefixes, nextKey } = await this.contract.read.queryObjects(args, {
        blockNumber: options?.blockNumber
      });
      const result = {
        objects: objects.map(({ key, state }) => ({
          key,
          state: {
            blobHash: state.blobHash,
            size: state.size,
            expiry: state.expiry,
            metadata: convertAbiMetadataToObject(state.metadata)
          }
        })),
        commonPrefixes,
        nextKey
      };
      return { result };
    } catch (error) {
      if (error instanceof import_viem3.ContractFunctionExecutionError) {
        if (error.message.includes("contract reverted")) {
          const isOutOfGasError = error.message.includes("wasm `unreachable` instruction executed") || error.message.includes("out of gas");
          if (isOutOfGasError) {
            throw new OutOfGasError(error.message);
          }
          throw new BucketNotFound(bucket);
        }
      }
      throw new UnhandledBucketError(`Failed to query bucket: ${error}`);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BucketManager
});
