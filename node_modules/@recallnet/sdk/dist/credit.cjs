"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/entities/credit.ts
var credit_exports = {};
__export(credit_exports, {
  CreditManager: () => CreditManager
});
module.exports = __toCommonJS(credit_exports);
var import_viem = require("viem");
var import_contracts = require("@recallnet/contracts");

// src/errors.ts
var import_address = require("@recallnet/fvm/address");
var InvalidValue = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValue";
  }
};
var UnhandledCreditError = class extends Error {
  constructor(message) {
    super(`Credit error: ${message}`);
    this.name = "UnhandledCreditError";
  }
};
var InsufficientFunds = class extends Error {
  constructor(amount) {
    super(`Insufficient funds: balance less than amount '${amount}'`);
    this.name = "InsufficientFunds";
  }
};
function isActorNotFoundError(error) {
  const isActorNotFound = error.message.includes(
    "actor::resolve_address -- actor not found"
  );
  const addressMatch = error.message.match(/f410[a-z0-9]+/i);
  return {
    isActorNotFound,
    address: addressMatch ? import_address.FilEthAddress.fromString(addressMatch[0]).toEthAddressHex() : null
  };
}
var ActorNotFound = class extends Error {
  constructor(address) {
    super(
      `Actor not found (hint: ensure the address is registered: '${address}')`
    );
    this.name = "ActorNotFound";
  }
};

// src/entities/credit.ts
var CreditManager = class {
  client;
  contract;
  constructor(client, contractAddress) {
    this.client = client;
    const chainId = client.publicClient?.chain?.id;
    if (!chainId) {
      throw new Error("Client chain ID not found");
    }
    const deployedCreditManagerAddress = import_contracts.creditManagerAddress[chainId];
    if (!deployedCreditManagerAddress) {
      throw new Error(`No contract address found for chain ID ${chainId}}`);
    }
    this.contract = (0, import_viem.getContract)({
      abi: import_contracts.creditManagerAbi,
      address: contractAddress || deployedCreditManagerAddress,
      client: {
        public: client.publicClient,
        wallet: client.walletClient
      }
    });
  }
  getContract() {
    return this.contract;
  }
  // Approve credit spending
  // TODO: maybe make the input params an object for easier optional params
  async approve(to, caller = [], creditLimit = 0n, gasFeeLimit = 0n, ttl = 0n, from) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for approving credits");
    }
    const fromAddress = from || this.client.walletClient.account.address;
    try {
      const args = [
        fromAddress,
        to,
        caller,
        creditLimit,
        gasFeeLimit,
        ttl
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.approveCredit(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        if (error.message.includes("does not match origin or caller")) {
          throw new InvalidValue(
            `'from' address '${fromAddress}' does not match origin or caller '${this.client.walletClient.account.address}'`
          );
        }
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to approve credits: ${error}`);
    }
  }
  // Buy credits
  async buy(amount, to) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for buying credits");
    }
    const balance = await this.client.publicClient.getBalance({
      address: this.client.walletClient.account.address
    });
    if (balance < amount) {
      throw new InsufficientFunds(amount);
    }
    try {
      const toAddress = to || this.client.walletClient.account.address;
      const args = [toAddress];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.buyCredit(args, {
        value: amount,
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.contract.write.buyCredit(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        if (error.message.includes("insufficient funds")) {
          throw new InsufficientFunds(amount);
        }
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to buy credits: ${error}`);
    }
  }
  // Revoke credit approval
  async revoke(to, requiredCaller = to, from) {
    if (!this.client.walletClient?.account) {
      throw new Error("Wallet client is not initialized for revoking credits");
    }
    const fromAddress = from || this.client.walletClient.account.address;
    try {
      const args = [
        fromAddress,
        to,
        requiredCaller
      ];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.revokeCredit(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        if (error.message.includes("does not match origin or caller")) {
          throw new InvalidValue(
            `'from' address '${fromAddress}' does not match origin or caller '${this.client.walletClient.account.address}'`
          );
        }
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to revoke credits: ${error}`);
    }
  }
  // Set account sponsor
  async setAccountSponsor(sponsor, from) {
    if (!this.client.walletClient?.account) {
      throw new Error(
        "Wallet client is not initialized for setting account sponsor"
      );
    }
    const fromAddress = from || this.client.walletClient.account.address;
    try {
      const args = [fromAddress, sponsor];
      const gasPrice = await this.client.publicClient.getGasPrice();
      const { request } = await this.contract.simulate.setAccountSponsor(args, {
        account: this.client.walletClient.account,
        gasPrice
      });
      const hash = await this.client.walletClient.writeContract(request);
      const tx = await this.client.publicClient.waitForTransactionReceipt({
        hash
      });
      return { meta: { tx }, result: {} };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        const { isActorNotFound, address } = isActorNotFoundError(error);
        if (isActorNotFound) {
          throw new ActorNotFound(address);
        }
      }
      throw new UnhandledCreditError(`Failed to set account sponsor: ${error}`);
    }
  }
  // Get account details including approvals
  async getAccount(address, blockNumber) {
    try {
      const forAddress = address || this.client.walletClient?.account?.address;
      if (!forAddress)
        throw new InvalidValue(
          "Must provide an address or connect a wallet client"
        );
      const args = [forAddress];
      const result = await this.contract.read.getAccount(args, { blockNumber });
      return { result };
    } catch (error) {
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          const emptyAccount = {
            capacityUsed: 0n,
            creditFree: 0n,
            creditCommitted: 0n,
            creditSponsor: "0x0000000000000000000000000000000000000000",
            lastDebitEpoch: 0n,
            approvalsTo: [],
            approvalsFrom: [],
            maxTtl: 0n,
            gasAllowance: 0n
          };
          return { result: emptyAccount };
        }
      }
      throw new UnhandledCreditError(`Failed to get account details: ${error}`);
    }
  }
  // Get credit approvals
  async getCreditApprovals(forAddress, {
    filterFrom,
    filterTo,
    blockNumber
  } = {}) {
    let {
      result: { approvalsTo, approvalsFrom }
    } = await this.getAccount(forAddress, blockNumber);
    approvalsTo = filterTo ? approvalsTo.filter((approval) => approval.addr === filterTo) : approvalsTo;
    approvalsFrom = filterFrom ? approvalsFrom.filter((approval) => approval.addr === filterFrom) : approvalsFrom;
    return { result: { approvalsTo, approvalsFrom } };
  }
  // Get credit balance
  async getCreditBalance(address, blockNumber) {
    try {
      const forAddress = address || this.client.walletClient?.account?.address;
      if (!forAddress)
        throw new InvalidValue(
          "Must provide an address or connect a wallet client"
        );
      const args = [forAddress];
      const result = await this.contract.read.getCreditBalance(args, {
        blockNumber
      });
      return { result };
    } catch (error) {
      if (error instanceof InvalidValue) {
        throw error;
      }
      if (error instanceof import_viem.ContractFunctionExecutionError) {
        const { isActorNotFound } = isActorNotFoundError(error);
        if (isActorNotFound) {
          const emptyBalance = {
            creditFree: 0n,
            creditCommitted: 0n,
            creditSponsor: import_viem.zeroAddress,
            lastDebitEpoch: 0n,
            approvalsTo: [],
            approvalsFrom: [],
            gasAllowance: 0n
          };
          return { result: emptyBalance };
        }
      }
      throw new UnhandledCreditError(`Failed to get credit balance: ${error}`);
    }
  }
  // Get credit stats
  async getCreditStats(blockNumber) {
    try {
      const result = await this.contract.read.getCreditStats({ blockNumber });
      return { result };
    } catch (error) {
      throw new UnhandledCreditError(`Failed to get credit stats: ${error}`);
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CreditManager
});
