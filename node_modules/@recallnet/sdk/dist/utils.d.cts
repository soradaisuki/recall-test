import { TransactionReceipt, Hex, GetEventArgs, Abi, PublicClient, Hash, Address } from 'viem';

declare function hexToBase64(hex: Hex, safeUrl?: boolean): string;
type SnakeToCamel<S extends string> = S extends `${infer T}_${infer U}` ? `${T}${Capitalize<SnakeToCamel<U>>}` : S;
type SnakeToCamelCase<T> = T extends Array<infer U> ? Array<SnakeToCamelCase<U>> : T extends object ? {
    [K in keyof T as SnakeToCamel<string & K>]: SnakeToCamelCase<T[K]>;
} : T;
declare function snakeToCamel<T>(obj: T extends Record<string, unknown> ? T : never): SnakeToCamelCase<T>;
declare function camelToSnake<T>(obj: T extends Record<string, unknown> ? T : never): SnakeToCamelCase<T>;
interface FileHandler {
    readFile: (input: string | File | Uint8Array) => Promise<{
        data: Uint8Array;
        contentType?: string;
        size: bigint;
    }>;
}
declare const createFileHandler: () => FileHandler;
/**
 * Metadata for read or write operations (currently only `tx` is used, via write operations)
 * @param hash Transaction hash, if the operation was a write
 */
interface Metadata {
    tx?: TransactionReceipt;
}
type Result<T = unknown> = {
    result: T;
    meta?: Metadata;
};
declare function parseEventFromTransaction<T extends GetEventArgs<Abi, string>>(client: PublicClient, abi: Abi, eventName: string, hash: Hash): Promise<T>;
declare function convertMetadataToAbiParams(value: Record<string, string>): {
    key: string;
    value: string;
}[];
declare function convertAbiMetadataToObject(metadata: readonly {
    key: string;
    value: string;
}[]): Record<string, string>;
declare function actorIdToMaskedEvmAddress(actorId: number): Address;

export { type FileHandler, type Metadata, type Result, type SnakeToCamel, type SnakeToCamelCase, actorIdToMaskedEvmAddress, camelToSnake, convertAbiMetadataToObject, convertMetadataToAbiParams, createFileHandler, hexToBase64, parseEventFromTransaction, snakeToCamel };
